!function(){"use strict";var e=1e-6,n="undefined"!=typeof Float32Array?Float32Array:Array,t=Math.PI/180;function i(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var o=function(e,n,t,i,o){var r,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e};function r(){var e=new n(3);return n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,t,i){var o=new n(3);return o[0]=e,o[1]=t,o[2]=i,o}function s(e,n,t,i){return e[0]=n,e[1]=t,e[2]=i,e}function u(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e}function c(e,n,t,i){var o=n[0],r=n[1],a=n[2];return e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r),e[2]=a+i*(t[2]-a),e}function d(){var e=new n(2);return n!=Float32Array&&(e[0]=0,e[1]=0),e}function l(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t}function p(e,t){var i=new n(2);return i[0]=e,i[1]=t,i}function h(e,n){return e[0]=n[0],e[1]=n[1],e}function f(e,n,t){return e[0]=n,e[1]=t,e}function v(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e}function g(e){var n=e[0],t=e[1];return Math.hypot(n,t)}r(),function(){var e=d()}();const m=a(0,1,0);class x{constructor({device:e,aspect:n=1,fov:t=75,near:o=.1,far:a=1e3}){this.device=e,this.buffer=e.createBuffer({size:32*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=n,this.fov=t,this.near=o,this.far=a,this.projectionMatrix=i(),this.viewMatrix=i(),this.position=r(),this.target=r()}updateProjection(){const{device:e,buffer:n,projectionMatrix:i,aspect:r,fov:a,near:s,far:u}=this;o(i,a*t,r,s,u),e.queue.writeBuffer(n,0,i)}updateView(){const{device:n,buffer:t,viewMatrix:i,position:o,target:r}=this;var a,s,u,c,d,l,p,h,f,v,g,x,k,y,b,w,z,E,S,_,M,P,B;a=i,u=r,c=m,b=(s=o)[0],w=s[1],z=s[2],E=c[0],S=c[1],_=c[2],M=u[0],P=u[1],B=u[2],Math.abs(b-M)<e&&Math.abs(w-P)<e&&Math.abs(z-B)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(g=b-M,x=w-P,k=z-B,d=S*(k*=y=1/Math.hypot(g,x,k))-_*(x*=y),l=_*(g*=y)-E*k,p=E*x-S*g,(y=Math.hypot(d,l,p))?(d*=y=1/y,l*=y,p*=y):(d=0,l=0,p=0),h=x*p-k*l,f=k*d-g*p,v=g*l-x*d,(y=Math.hypot(h,f,v))?(h*=y=1/y,f*=y,v*=y):(h=0,f=0,v=0),a[0]=d,a[1]=h,a[2]=g,a[3]=0,a[4]=l,a[5]=f,a[6]=x,a[7]=0,a[8]=p,a[9]=v,a[10]=k,a[11]=0,a[12]=-(d*b+l*w+p*z),a[13]=-(h*b+f*w+v*z),a[14]=-(g*b+x*w+k*z),a[15]=1),n.queue.writeBuffer(t,64,i)}}const k=r(),y=d(),b=r();class w{constructor({position:e,target:t}){var i,o;this.target=t,this.gamepad=null,this.keyboard=r(),this.pointer={movement:d(),position:d()},this.buttons={primary:!1},this.look={state:p(.5*Math.PI,0),target:p(.5*Math.PI,0)},this.position={state:e,target:(i=e,o=new n(3),o[0]=i[0],o[1]=i[1],o[2]=i[2],o)},this.speed={state:8,target:8},this.vectors={forward:r(),right:r(),worldUp:a(0,1,0)},t.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnected.bind(this),!1),window.addEventListener("gamepadconnected",this.onGamepadConnected.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),t.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}lock(){const{isLocked:e,target:n}=this;e||n.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onGamepadDisconnected({gamepad:{index:e}}){const{gamepad:n}=this;n===e&&(this.gamepad=null)}onGamepadConnected({gamepad:{index:e}}){this.gamepad=e}onKeyDown({key:e,repeat:n,target:t}){const{isLocked:i,keyboard:o}=this;if(i&&!n&&"INPUT"!==t.tagName)switch(e.toLowerCase()){case"w":o[2]=1;break;case"s":o[2]=-1;break;case"a":o[0]=-1;break;case"d":o[0]=1;break;case" ":o[1]=1;break;case"shift":o[1]=-1}}onKeyUp({key:e}){const{isLocked:n,keyboard:t}=this;if(n)switch(e.toLowerCase()){case"w":t[2]>0&&(t[2]=0);break;case"s":t[2]<0&&(t[2]=0);break;case"a":t[0]<0&&(t[0]=0);break;case"d":t[0]>0&&(t[0]=0);break;case" ":t[1]>0&&(t[1]=0);break;case"shift":t[1]<0&&(t[1]=0)}}onMouseDown({button:e}){const{isLocked:n,pointer:t}=this;n?t.isDown=0===e||2===e:this.lock()}onMouseMove({clientX:e,clientY:n,movementX:t,movementY:i}){const{sensitivity:o}=w,{isLocked:r,pointer:{movement:a,position:s}}=this;r&&(a[0]-=t*o.pointer,a[1]+=i*o.pointer,f(s,e/window.innerWidth*2-1,-n/window.innerHeight*2+1))}onMouseUp({button:e}){const{isLocked:n,pointer:t}=this;!n||0!==e&&2!==e||(t.isDown=!1)}onMouseWheel(e){const{sensitivity:n,minSpeed:t,speedRange:i}=w,{isLocked:o,speed:r}=this;if(e.ctrlKey&&e.preventDefault(),!o)return;const a=Math.min(Math.max((Math.log(r.target)-t)/i-e.deltaY*n.wheel,0),1);r.target=Math.exp(t+a*i)}onPointerLock(){const{buttons:e,keyboard:n,pointer:t}=this;this.isLocked=!!document.pointerLockElement,this.isLocked||(e.primary=!1,s(n,0,0,0),t.isDown=!1)}update(e){const{minPhi:n,maxPhi:t,sensitivity:i}=w,{isLocked:o,buttons:r,gamepad:a,keyboard:d,pointer:l,look:p,position:v,speed:g,vectors:m}=this;if(o){if(r.primary=l.isDown,z=d,(x=b)[0]=z[0],x[1]=z[1],x[2]=z[2],h(y,l.movement),null!==a){const{axes:e,buttons:n}=navigator.getGamepads()[a];(n[6]&&n[6].pressed||n[7]&&n[7].pressed)&&(r.primary=!0),Math.max(Math.abs(e[2]),Math.abs(e[3]))>.1&&f(y,-e[2]*i.gamepad,-e[3]*i.gamepad),Math.max(Math.abs(e[0]),Math.abs(e[1]))>.1&&s(b,e[0],0,-e[1])}p.target[0]=Math.min(Math.max(p.target[0]+y[1],n),t),p.target[1]+=y[0]}var x,z;f(l.movement,0,0);const E=1-Math.exp(-20*e);if(function(e,n,t,i){var o=n[0],r=n[1];e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r)}(p.state,p.state,p.target,E),g.state=g.state*(1-E)+g.target*E,s(m.forward,Math.sin(p.state[0])*Math.sin(p.state[1]),Math.cos(p.state[0]),Math.sin(p.state[0])*Math.cos(p.state[1])),function(e,n){var t=n[0],i=n[1],o=n[2],r=t*t+i*i+o*o;r>0&&(r=1/Math.sqrt(r)),e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r}(m.right,function(e,n,t){var i=n[0],o=n[1],r=n[2],a=t[0],s=t[1],u=t[2];return e[0]=o*u-r*s,e[1]=r*a-i*u,e[2]=i*s-o*a,e}(m.right,m.forward,m.worldUp)),0!==b[0]||0!==b[1]||0!==b[2]){s(k,0,0,0),u(k,k,m.right,b[0]),u(k,k,m.worldUp,b[1]),u(k,k,m.forward,b[2]),s(b,0,0,0);const n=function(e){var n=e[0],t=e[1],i=e[2];return Math.hypot(n,t,i)}(k);n>1&&function(e,n,t){e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t}(k,k,1/n),u(v.target,v.target,k,e*g.state)}c(v.state,v.state,v.target,1-Math.exp(-10*e))}}w.sensitivity={gamepad:.03,pointer:.003,wheel:3e-4},w.minPhi=.01,w.maxPhi=Math.PI-.01,w.minSpeed=Math.log(4),w.maxSpeed=Math.log(32),w.speedRange=w.maxSpeed-w.minSpeed;const z=r();class E{constructor({renderer:e,voxels:n}){this.renderer=e,this.voxels=n,this.colors={background:{day:a(.2,.6,.6),night:a(.05,.05,.1)},sunlight:{day:a(1,1,.6),night:a(.1,.1,.2)}},this.target=1,this.state=0;const t=document.getElementById("light"),[i,o]=t.getElementsByTagName("svg");i.addEventListener("click",(()=>{t.classList.remove("night"),t.classList.add("day"),this.target=1}),!1),o.addEventListener("click",(()=>{t.classList.remove("day"),t.classList.add("night"),this.target=0}),!1)}update(e){if(Math.abs(this.state-this.target)<.001)return;const{colors:n,renderer:t,target:i,voxels:o}=this,r=1-Math.exp(-10*e);this.state=this.state*(1-r)+i*r,c(z,n.background.night,n.background.day,this.state),t.setBackground(z[0],z[1],z[2]),c(z,n.sunlight.night,n.sunlight.day,this.state),o.setSunlight(z[0],z[1],z[2])}}class S{constructor({camera:e,device:n,instances:t,samples:i}){this.geometry=(e=>{const n=e.createBuffer({size:216*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.1,-.1,.1,0,0,1,.1,-.1,.1,0,0,1,.1,.1,.1,0,0,1,.1,.1,.1,0,0,1,-.1,.1,.1,0,0,1,-.1,-.1,.1,0,0,1,.1,-.1,-.1,0,0,-1,-.1,-.1,-.1,0,0,-1,-.1,.1,-.1,0,0,-1,-.1,.1,-.1,0,0,-1,.1,.1,-.1,0,0,-1,.1,-.1,-.1,0,0,-1,-.1,.1,-.1,0,1,0,.1,.1,-.1,0,1,0,.1,.1,.1,0,1,0,.1,.1,.1,0,1,0,-.1,.1,.1,0,1,0,-.1,.1,-.1,0,1,0,-.1,-.1,.1,0,-1,0,.1,-.1,.1,0,-1,0,.1,-.1,-.1,0,-1,0,.1,-.1,-.1,0,-1,0,-.1,-.1,-.1,0,-1,0,-.1,-.1,.1,0,-1,0,.1,-.1,-.1,1,0,0,.1,-.1,.1,1,0,0,.1,.1,.1,1,0,0,.1,.1,.1,1,0,0,.1,.1,-.1,1,0,0,.1,-.1,-.1,1,0,0,-.1,-.1,.1,-1,0,0,-.1,-.1,-.1,-1,0,0,-.1,.1,-.1,-1,0,0,-.1,.1,-.1,-1,0,0,-.1,.1,.1,-1,0,0,-.1,-.1,.1,-1,0,0]),n.unmap(),n})(n),this.instances=t,this.pipeline=n.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]}],entryPoint:"main",module:n.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) direction : vec3<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst worldUp : vec3<f32> = vec3<f32>(0, 1, 0);\n\nfn getRotation(direction : vec3<f32>) -> mat3x3<f32> {\n  var xaxis : vec3<f32> = normalize(cross(worldUp, direction));\n  var yaxis : vec3<f32> = normalize(cross(direction, xaxis));\n  return mat3x3<f32>(xaxis, yaxis, direction);\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(projectile : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32> = getRotation(projectile.direction);\n  var position : vec3<f32> = rotation * projectile.position + projectile.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * projectile.normal);\n  out.depth = -mvPosition.z;\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@fragment\nfn main(projectile : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(1);\n  output.data = vec4<f32>(normalize(projectile.normal), projectile.depth);\n  return output;\n}\n"}),targets:[{format:"rgba8unorm"},{format:"rgba16float"}]},primitive:{topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}}]})}render(e){const{bindings:n,instances:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,n),e.setVertexBuffer(0,i),e.setVertexBuffer(1,t,16),e.drawIndirect(t,0)}}class _{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const n=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}],entryPoint:"main",module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"})},fragment:{entryPoint:"main",module:e.createShaderModule({code:"\n@group(0) @binding(0) var colorTexture : texture_2d<f32>;\n@group(0) @binding(1) var dataTexture : texture_2d<f32>;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.2;\nconst depthScale : f32 = 0.4;\nconst normalScale : f32 = 0.4;\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edge(pixel : vec2<i32>) -> f32 {\n  let pixelCenter : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let pixelLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  let pixelRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  let pixelUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  let pixelDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  let edge : vec4<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return clamp(max((edge.x + edge.y + edge.z) * normalScale, edge.w * depthScale), 0, 1);\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  let pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, edgeColor, edge(pixel) * edgeIntensity);\n  return vec4<f32>(color, 1);\n}\n"}),targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures([e,n]){const{device:t,pipeline:i}=this;this.bindings=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:e.resolveTarget},{binding:1,resource:n.resolveTarget}]})}render(e,n){const{bindings:t,descriptor:i,geometry:o,pipeline:r}=this;i.colorAttachments[0].view=n;const a=e.beginRenderPass(i);a.setPipeline(r),a.setBindGroup(0,t),a.setVertexBuffer(0,o),a.draw(6,1,0,0),a.end()}}class M{constructor({adapter:e,camera:n,device:t,samples:i=4}){this.camera=n,this.device=t,this.samples=i;const o=navigator.gpu.getPreferredCanvasFormat(e);this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:o}),this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.postprocessing=new _({device:t,format:o}),this.scene=[],this.textures=new Map}render(e){const{context:n,descriptor:t,postprocessing:i,scene:o}=this,r=e.beginRenderPass(t);o.forEach((e=>e.render(r))),r.end(),i.render(e,n.getCurrentTexture().createView())}setBackground(e,n,t){const{descriptor:{colorAttachments:[{clearValue:i}]}}=this;i.r=e,i.g=n,i.b=t}setSize(e,n){const{camera:t,canvas:i,descriptor:o,postprocessing:r}=this,a=window.devicePixelRatio||1,s=[Math.floor(e*a),Math.floor(n*a)];i.width=s[0],i.height=s[1],i.style.width=`${e}px`,i.style.height=`${n}px`,t.aspect=e/n,t.updateProjection(),this.updateTexture(o.colorAttachments[0],"rgba8unorm","color",s),this.updateTexture(o.colorAttachments[1],"rgba16float","data",s),this.updateTexture(o.depthStencilAttachment,"depth24plus","depth",s,!1),r.bindTextures(o.colorAttachments)}updateTexture(e,n,t,i,o=!0){const{device:r,samples:a,textures:s}=this,u=s.get(t);u&&u.forEach((e=>e.destroy())),s.set(t,[a,...o?[1]:[]].map((t=>{const o=r.createTexture({format:n,sampleCount:t,size:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|(1===t?GPUTextureUsage.TEXTURE_BINDING:0)});return 1===t?e.resolveTarget=o.createView():e.view=o.createView(),o})))}}var P="\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const B=({count:e,width:n,height:t,generator:i})=>`\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${P}\n\n${i}\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  let id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  let tex : i32 = id / atlas.stride;\n  let index : i32 = id - tex * atlas.stride;\n  let y : i32 = index / atlas.width;\n  let pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class L{constructor({device:e,count:n=4,width:t=16,height:i=16}){this.device=e,this.count=n,this.width=t,this.height=i,this.texture=e.createTexture({dimension:"2d",size:[t,i,n],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.workgroups=Math.ceil(n*t*i/256)}compute(e="\nconst stone : vec3<f32> = vec3<f32>(0.6, 0.6, 0.8);\nconst dirt : vec4<f32> = vec4<f32>(1.0, 1.0, 1.0, 1.0);\nconst grass : vec4<f32> = vec4<f32>(0.6, 1.0, 0.6, 1.0);\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  switch (texture) {\n    default {\n      var n = (max(noise3(vec3<f32>(vec2<f32>(pixel) * vec2<f32>(0.75, 1), 0)) - 0.5, 0) - 0.5) * 0.1;\n      return vec4<f32>(stone + n, 1.0);\n    }\n    case 1 {\n      return dirt;\n    }\n    case 2 {\n      var n = (max(noise3(vec3<f32>(vec2<f32>(pixel), 0)) - 0.5, 0) - 0.5) * 0.1;\n      return vec4<f32>(grass.xyz + n, 1.0);\n    }\n    case 3 {\n      if (pixel.y > 4 - i32(4 * noise3(vec3<f32>(vec2<f32>(pixel), 0)))) {\n        return dirt;\n      }\n      return grass;\n    }\n  }\n}\n"){const{device:n,count:t,width:i,height:o,texture:r,workgroups:a}=this,s=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:B({count:t,width:i,height:o,generator:e})})}}),u=n.createCommandEncoder(),c=u.beginComputePass();c.setPipeline(s),c.setBindGroup(0,n.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:r.createView()}]})),c.dispatchWorkgroups(a),c.end(),n.queue.submit([u.finish()])}setupDragAndDrop(){window.addEventListener("dragenter",(e=>e.preventDefault()),!1),window.addEventListener("dragover",(e=>e.preventDefault()),!1),window.addEventListener("drop",(e=>{e.preventDefault();const[n]=e.dataTransfer.files;if(!n||0!==n.type.indexOf("image/"))return;const t=new Image;t.addEventListener("load",(()=>{const{device:e,count:n,width:i,height:o,texture:r}=this,a=document.createElement("canvas"),s=a.getContext("2d");a.width=i,a.height=o*n,s.drawImage(t,0,0);const u=s.getImageData(0,0,a.width,a.height);e.queue.writeTexture({texture:r},u.data.buffer,{bytesPerRow:4*i,rowsPerImage:o},[i,o,n])}),!1),t.src=URL.createObjectURL(n)}),!1)}}class T{constructor({camera:e,chunks:n,device:t,samples:i}){this.atlas=new L({device:t}),this.chunks=n,this.device=t,this.geometry=(e=>{const n=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n})(t),this.sunlight={buffer:t.createBuffer({size:3*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:new Float32Array(3)},this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:4,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:5,offset:5*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:t.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) light : f32,\n  @location(4) face : f32,\n  @location(5) texture : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\nconst PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  let c : f32 = cos(rad);\n  let s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  let c : f32 = cos(rad);\n  let s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn getRotation(face : i32) -> mat3x3<f32> {\n  switch (face) {\n    default {\n      return mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      return rotateX(PI * -0.5);\n    }\n    case 2 {\n      return rotateX(PI * 0.5);\n    }\n    case 3 {\n      return rotateY(PI * -0.5);\n    }\n    case 4 {\n      return rotateY(PI * 0.5);\n    }\n    case 5 {\n      return rotateY(PI);\n    }\n  }\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> sunlight : vec3<f32>;\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  let rotation : mat3x3<f32> = getRotation(i32(voxel.face));\n  let position : vec3<f32> = rotation * voxel.position + voxel.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.depth = -mvPosition.z;\n  out.light = sunlight * pow(voxel.light, 8);\n  out.texture = i32(voxel.texture);\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@group(0) @binding(2) var atlas : texture_2d_array<f32>;\n@group(0) @binding(3) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.color *= vec4<f32>(face.light, 1);\n  output.data = vec4<f32>(normalize(face.normal), face.depth);\n  return output;\n}\n"}),targets:[{format:"rgba8unorm"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:{buffer:this.sunlight.buffer}},{binding:2,resource:this.atlas.texture.createView()},{binding:3,resource:t.createSampler()}]})}render(e){const{bindings:n,chunks:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,n),e.setVertexBuffer(0,i),t.forEach((({faces:n})=>{e.setVertexBuffer(1,n,16),e.drawIndirect(n,0)}))}setSunlight(e,n,t){const{device:i,sunlight:o}=this;o.data[0]=e,o.data[1]=n,o.data[2]=t,i.queue.writeBuffer(o.buffer,0,o.data)}}class G{constructor({chunkSize:e,device:n,position:t}){this.bindings={},this.position=l(t),this.bounds=n.createBuffer({mappedAtCreation:!0,size:6*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.bounds.getMappedRange()).set([e.x,e.y,e.z]),this.bounds.unmap(),this.data=n.createBuffer({size:(e.x*e.y*e.z*2+2*(1+e.x*e.z*3)+1+1)*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),this.faces=n.createBuffer({size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(e.x*e.y*e.z*.5)*6*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),this.offset=n.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.offset.getMappedRange()).set([t[0]*e.x,0,t[1]*e.z]),this.offset.unmap()}}G.compute=({atomicBounds:e,atomicInstanceCount:n,atomicQueueCount:t,atomicLight:i,atomicValue:o,chunkSize:r})=>`\n  const chunkSize : vec3<i32> = vec3<i32>(${r.x}, ${r.y}, ${r.z});\n  const maxLight : u32 = 255;\n\n  struct Bounds {\n    min : array<${e?"atomic<u32>":"u32"}, 3>,\n    max : array<${e?"atomic<u32>":"u32"}, 3>,\n  }\n\n  struct Faces {\n    vertexCount : u32,\n    instanceCount : ${n?"atomic<u32>":"u32"},\n    firstVertex : u32,\n    firstInstance : u32,\n    data : array<f32>,\n  }\n\n  struct Queue {\n    count : ${t?"atomic<u32>":"u32"},\n    data : array<u32, ${r.x*r.z*3}>,\n  }\n\n  struct Voxel {\n    value : ${o?"atomic<u32>":"u32"},\n    light : ${i?"atomic<u32>":"u32"},\n  }\n\n  struct Chunk {\n    voxels : array<Voxel, ${r.x*r.y*r.z}>,\n    queues : array<Queue, 2>,\n    queue : u32,\n    remesh : u32,\n  }\n\n  fn getVoxel(pos : vec3<i32>) -> u32 {\n    return u32(pos.z * chunkSize.x * chunkSize.y + pos.y * chunkSize.x + pos.x);\n  }\n\n  fn getPos(voxel : u32) -> vec3<i32> {\n    let o : i32 = i32(voxel) % (chunkSize.x * chunkSize.y);\n    return vec3<i32>(\n      o % chunkSize.x,\n      o / chunkSize.x,\n      i32(voxel) / (chunkSize.x * chunkSize.y),\n    );\n  }\n`;class C{constructor({device:e,camera:n}){this.buffer=e.createBuffer({size:24*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),this.pipeline=e.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:e.createShaderModule({code:"\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<storage, read_write> frustum : array<vec4<f32>, 6>;\n\nfn update(index : i32, plane : vec4<f32>) {\n  frustum[index] = plane * (1 / length(plane.xyz));\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  let m : mat4x4<f32> = camera.projection * camera.view;\n  update(0, vec4<f32>(m[0].w - m[0].x, m[1].w - m[1].x, m[2].w - m[2].x, m[3].w - m[3].x));\n  update(1, vec4<f32>(m[0].w + m[0].x, m[1].w + m[1].x, m[2].w + m[2].x, m[3].w + m[3].x));\n  update(2, vec4<f32>(m[0].w + m[0].y, m[1].w + m[1].y, m[2].w + m[2].y, m[3].w + m[3].y));\n  update(3, vec4<f32>(m[0].w - m[0].y, m[1].w - m[1].y, m[2].w - m[2].y, m[3].w - m[3].y));\n  update(4, vec4<f32>(m[0].w - m[0].z, m[1].w - m[1].z, m[2].w - m[2].z, m[3].w - m[3].z));\n  update(5, vec4<f32>(m[0].w + m[0].z, m[1].w + m[1].z, m[2].w + m[2].z, m[3].w + m[3].z));\n}\n"})}}),this.bindings=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:this.buffer}}]})}compute(e){const{bindings:n,pipeline:t}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(1)}}const U=({chunkSize:e})=>`\n${G.compute({atomicQueueCount:!0,atomicLight:!0,chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n\nfn flood(pos : vec3<i32>, level : u32) {\n  // I really tried to make this with pointers\n  // and a single logic block but I couldn't manage to\n  // pass a ptr<storage, Chunk, read_write> to a function\n  if (pos.x == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (chunk_west.voxels[voxel].value != 0) {\n      chunk_west.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_west.voxels[voxel].light, level) < level) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&chunk_west.queues[chunk_west.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    let voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (chunk_east.voxels[voxel].value != 0) {\n      chunk_east.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_east.voxels[voxel].light, level) < level) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&chunk_east.queues[chunk_east.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (chunk_south.voxels[voxel].value != 0) {\n      chunk_south.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_south.voxels[voxel].light, level) < level) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&chunk_south.queues[chunk_south.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (chunk_north.voxels[voxel].value != 0) {\n      chunk_north.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_north.voxels[voxel].light, level) < level) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&chunk_north.queues[chunk_north.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  let voxel : u32 = getVoxel(pos);\n  if (chunk.voxels[voxel].value != 0) {\n    return;\n  }\n  if (atomicMax(&chunk.voxels[voxel].light, level) < level) {\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= uniforms.count) {\n    return;\n  }\n  let voxel : u32 = chunk.queues[uniforms.queue].data[id.x];\n  let light : u32 = atomicLoad(&chunk.voxels[voxel].light);\n  let pos : vec3<i32> = getPos(voxel);\n  for (var n : i32 = 0; n < 6; n++) {\n    let npos = pos + neighbors[n];\n    if (npos.y == -1 || npos.y == chunkSize.y) {\n      continue;\n    }\n    var level : u32 = light;\n    if (n != 0 || level < maxLight) {\n      level -= 1;\n    }\n    flood(npos, level);\n  }\n}\n`;class A{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:U({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups=i}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.lightingCompute||(n.bindings.lightingCompute=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingCompute),e.dispatchWorkgroupsIndirect(r,0)}}const R=({chunkSize:e})=>`\n${G.compute({chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> uniforms : Uniforms;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n\n@compute @workgroup_size(1)\nfn main() {\n  let count : u32 = chunk.queues[chunk.queue].count;\n  if (count == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n\n  uniforms.count = count;\n  uniforms.queue = chunk.queue;\n\n  workgroups[0] = u32(ceil(f32(count) / 256));\n  workgroups[1] = 1;\n  workgroups[2] = 1;\n\n  let next : u32 = (chunk.queue + 1) % 2;\n  chunk.queue = next;\n  chunk.queues[next].count = 0;\n\n  chunk.remesh = 1;\n}\n`;class q{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:R({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.lightingSetup||(n.bindings.lightingSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingSetup),e.dispatchWorkgroups(1)}}class I{constructor({chunkSize:e,device:n}){const t=n.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.propagate=new A({chunkSize:e,device:n,uniforms:t,workgroups:i}),this.setup=new q({chunkSize:e,device:n,uniforms:t,workgroups:i})}compute(e,n){const{propagate:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const N=({chunkSize:e})=>`\n${G.compute({atomicInstanceCount:!0,chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read> chunk : Chunk;\n@group(0) @binding(1) var<storage, read> chunk_east : Chunk;\n@group(0) @binding(2) var<storage, read> chunk_west : Chunk;\n@group(0) @binding(3) var<storage, read> chunk_north : Chunk;\n@group(0) @binding(4) var<storage, read> chunk_south : Chunk;\n@group(0) @binding(5) var<storage, read_write> faces : Faces;\n@group(0) @binding(6) var<uniform> position : vec3<i32>;\n\nstruct Normals {\n  f : vec3<i32>,\n  u : vec3<i32>,\n  v : vec3<i32>,\n}\n\nconst faceNormals = array<Normals, 6>(\n  Normals(vec3<i32>(0, 0, 1), vec3<i32>(0, 1, 0), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, 1, 0), vec3<i32>(0, 0, -1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, -1, 0), vec3<i32>(0, 0, 1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(-1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(0, 0, -1), vec3<i32>(0, 1, 0), vec3<i32>(-1, 0, 0)),\n);\n\nconst lightSamples = array<vec2<i32>, 5>(\n  vec2<i32>(0, 0),\n  vec2<i32>(-1, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, -1),\n  vec2<i32>(0, 1),\n);\n\nfn getNeighbor(pos : vec3<i32>) -> Voxel {\n  if (\n    pos.y < 0\n    || (pos.x < 0 && pos.z < 0)\n    || (pos.x >= chunkSize.x && pos.z < 0)\n    || (pos.x < 0 && pos.z >= chunkSize.z)\n    || (pos.x >= chunkSize.x && pos.z >= chunkSize.z)\n  ) {\n    return Voxel(1, 0);\n  }\n  if (pos.y >= chunkSize.y) {\n    return Voxel(0, maxLight);\n  }\n  if (pos.x < 0) {\n    return chunk_west.voxels[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.voxels[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.z < 0) {\n    return chunk_south.voxels[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))];\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.voxels[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))];\n  }\n  return chunk.voxels[getVoxel(pos)];\n}\n\nfn getLight(pos : vec3<i32>, u : vec3<i32>, v : vec3<i32>) -> f32 {\n  var level : f32;\n  var count : i32;\n  for (var i : i32 = 0; i < 5; i++) {\n    let uv = lightSamples[i];\n    let npos : vec3<i32> = pos + u * uv.x + v * uv.y;\n    let neighbor : Voxel = getNeighbor(npos);\n    if (neighbor.value == 0 && neighbor.light != 0) {\n      level += f32(neighbor.light);\n      count++;\n    }\n  }\n  return level / f32(max(count, 1)) / f32(maxLight);\n}\n\nfn getTexture(face : i32, value : u32) -> i32 {\n  switch (value) {\n    default {\n      return 0;\n    }\n    case 2 {\n      return 1; \n    }\n    case 3 {\n      if (face == 1) {\n        return 2;\n      }\n      if (face == 2) {\n        return 1;\n      }\n      return 3;\n    }\n  }\n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32, light : f32) {\n  if (light == 0) {\n    return;\n  }\n  let offset : u32 = atomicAdd(&faces.instanceCount, 1) * 6;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = light;\n  faces.data[offset + 4] = f32(face);\n  faces.data[offset + 5] = f32(texture);\n}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  let value : u32 = chunk.voxels[getVoxel(pos)].value;\n  if (value != 0) {\n    for (var face : i32 = 0; face < 6; face++) {\n      let npos : vec3<i32> = pos + faceNormals[face].f;\n      if (getNeighbor(npos).value == 0) {\n        pushFace(\n          position + pos,\n          face,\n          getTexture(face, value),\n          getLight(npos, faceNormals[face].u, faceNormals[face].v)\n        );\n      }\n    }\n  }\n}\n`;class V{constructor({chunkSize:e,device:n,workgroups:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:N({chunkSize:e})}),entryPoint:"main"}}),this.workgroups=t}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.mesherCompute||(n.bindings.mesherCompute=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[n,...n.neighbors,{data:n.faces},{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(i),e.setBindGroup(0,n.bindings.mesherCompute),e.dispatchWorkgroupsIndirect(o,0)}}const F=({chunkSize:e})=>`\n${G.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<uniform> frustum : array<vec4<f32>, 6>;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read> bounds : Bounds;\n@group(1) @binding(1) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(2) var<storage, read_write> faces : Faces;\n@group(1) @binding(3) var<uniform> position : vec3<i32>;\n\nfn isInFrustum() -> bool {\n  let origin : vec3<f32> = vec3<f32>(position);\n  for (var i : i32 = 0; i < 6; i++) {\n    let plane : vec4<f32> = frustum[i];\n    var corner : vec3<f32>;\n    for (var j : i32 = 0; j < 3; j++) {\n      if (plane[j] > 0) {\n        corner[j] = f32(bounds.max[j]);\n      } else {\n        corner[j] = f32(bounds.min[j]);\n      }\n    }\n    if ((dot(plane.xyz, origin + corner) + plane.w) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  if (isInFrustum()) {\n    faces.vertexCount = 6;\n  } else {\n    faces.vertexCount = 0;\n  }\n  if (chunk.remesh == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n  chunk.remesh = 0;\n  faces.instanceCount = 0;\n  workgroups[0] = u32(ceil(f32(chunkSize.x) / 4));\n  workgroups[1] = u32(ceil(f32(chunkSize.y) / 4));\n  workgroups[2] = u32(ceil(f32(chunkSize.z) / 4));\n}\n`;class O{constructor({chunkSize:e,device:n,frustum:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:F({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.mesherSetup||(n.bindings.mesherSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.bounds}},{binding:1,resource:{buffer:n.data}},{binding:2,resource:{buffer:n.faces}},{binding:3,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.mesherSetup),e.dispatchWorkgroups(1)}}class Y{constructor({chunkSize:e,device:n,frustum:t}){const i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.mesh=new V({chunkSize:e,device:n,workgroups:i}),this.setup=new O({chunkSize:e,device:n,frustum:t,workgroups:i})}compute(e,n){const{mesh:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const D=({chunkSize:e,count:n})=>`\n${G.compute({atomicQueueCount:!0,atomicValue:!0,chunkSize:e})}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  distance: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> state : array<Projectile, ${n}>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n@group(1) @binding(5) var<uniform> position : vec3<i32>;\n\nfn flood(pos : vec3<i32>) {\n  if (pos.y == -1 || pos.y == chunkSize.y) {\n    return;\n  }\n  if (pos.x == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (atomicLoad(&chunk_west.voxels[voxel].value) == 0 && chunk_west.voxels[voxel].light != 0) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&chunk_west.queues[chunk_west.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    let voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (atomicLoad(&chunk_east.voxels[voxel].value) == 0 && chunk_east.voxels[voxel].light != 0) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&chunk_east.queues[chunk_east.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (atomicLoad(&chunk_south.voxels[voxel].value) == 0 && chunk_south.voxels[voxel].light != 0) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&chunk_south.queues[chunk_south.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (atomicLoad(&chunk_north.voxels[voxel].value) == 0 && chunk_north.voxels[voxel].light != 0) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&chunk_north.queues[chunk_north.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  let voxel : u32 = getVoxel(pos);\n  if (atomicLoad(&chunk.voxels[voxel].value) == 0 && chunk.voxels[voxel].light != 0) {\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(${Math.min(n,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (\n    id.x >= ${n}\n    || state[id.x].state == 0\n  ) {\n    return;\n  }\n  let pos : vec3<i32> = vec3<i32>(floor(state[id.x].position)) - position;\n  for (var z : i32 = -1; z <= 1; z++) {\n    for (var y : i32 = -1; y <= 1; y++) {\n      for (var x : i32 = -1; x <= 1; x++) {\n        let npos : vec3<i32> = pos + vec3<i32>(x, y, z);\n        if (\n          npos.x < 0 || npos.x >= chunkSize.x\n          || npos.y < 0 || npos.y >= chunkSize.y\n          || npos.z < 0 || npos.z >= chunkSize.z\n        ) {\n          continue;\n        }\n        if (npos.y == 0) {\n          state[id.x].state = 0;\n          continue;\n        }\n        let voxel : u32 = getVoxel(npos);\n        if (atomicMin(&chunk.voxels[voxel].value, 0) != 0) {\n          state[id.x].state = 2;\n          for (var n : i32 = 0; n < 6; n++) {\n            flood(npos + neighbors[n]);\n          }\n        }\n      }\n    }\n  }\n}\n`;class j{constructor({chunkSize:e,count:n,device:t,state:i}){this.device=t,this.pipeline=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:D({chunkSize:e,count:n})}),entryPoint:"main"}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:i}}]}),this.workgroups=Math.ceil(n/256)}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.projectiles||(n.bindings.projectiles=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors,{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.projectiles),e.dispatchWorkgroups(r)}}const $=({count:e})=>`\nstruct Input {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  enabled: atomic<u32>,\n}\n\nstruct Instances {\n  vertexCount : u32,\n  instanceCount : atomic<u32>,\n  firstVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  distance: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<uniform> delta : f32;\n@group(0) @binding(1) var<storage, read_write> input : Input;\n@group(0) @binding(2) var<storage, read_write> instances : Instances;\n@group(0) @binding(3) var<storage, read_write> state : array<Projectile, ${e}>;\n\nfn pushInstance(position : vec3<f32>, direction : vec3<f32>) {\n  let offset : u32 = atomicAdd(&instances.instanceCount, 1) * 6;\n  instances.data[offset] = position.x;\n  instances.data[offset + 1] = position.y;\n  instances.data[offset + 2] = position.z;\n  instances.data[offset + 3] = direction.x;\n  instances.data[offset + 4] = direction.y;\n  instances.data[offset + 5] = direction.z;\n}\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  if (state[id.x].state == 1) {\n    state[id.x].distance++;\n    if (state[id.x].distance > 256) {\n      state[id.x].state = 0;\n      return;\n    }\n    let direction : vec3<f32> = state[id.x].direction;\n    state[id.x].position += direction * delta * 60;\n    pushInstance(state[id.x].position, direction);\n    return;\n  }\n  if (state[id.x].state == 2) {\n    // @incomplete: Spawn explosion at state[id.x].position\n    state[id.x].state = 0;\n  }\n  if (atomicMin(&input.enabled, 0) != 0) {\n    state[id.x].position = input.position; \n    state[id.x].direction = input.direction; \n    state[id.x].distance = 0;\n    state[id.x].state = 1;\n  }\n}\n`;class W{constructor({count:e,delta:n,device:t,input:i,instances:o,state:r}){this.pipeline=t.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:t.createShaderModule({code:$({count:e})})}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:i.buffer}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:r}}]}),this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:n,pipeline:t,workgroups:i}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(i)}}const X=new Uint32Array(1);class Q{constructor({count:e=32,chunkSize:n,device:t}){this.device=t,this.delta={buffer:t.createBuffer({size:Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:new Float32Array(1)},this.input={buffer:t.createBuffer({size:8*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),data:new Float32Array(8)},this.instances=t.createBuffer({mappedAtCreation:!0,size:4*Uint32Array.BYTES_PER_ELEMENT+6*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),this.state=t.createBuffer({size:12*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.instances.getMappedRange(0,Uint32Array.BYTES_PER_ELEMENT))[0]=36,this.instances.unmap(),this.passes={compute:new j({chunkSize:n,count:e,device:t,state:this.state}),step:new W({count:e,delta:this.delta,device:t,input:this.input,instances:this.instances,state:this.state})}}compute(e,n){const{passes:{compute:t}}=this;t.compute(e,n)}shoot(e,n){const{device:t,input:i}=this;i.data.set(n),i.data.set(e,4),new Uint32Array(i.data.buffer,28,1)[0]=1,t.queue.writeBuffer(i.buffer,0,i.data.buffer)}step(e,n){const{delta:{buffer:t,data:i},device:o,instances:r,passes:{step:a}}=this;i[0]=n,o.queue.writeBuffer(t,0,i),o.queue.writeBuffer(r,4,X),a.compute(e)}}const H=({chunkSize:e})=>`\n${G.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  let voxel = getVoxel(pos);\n  if (chunk.voxels[voxel].value == 2 && chunk.voxels[getVoxel(pos + vec3<i32>(0, 1, 0))].value == 0) {\n    chunk.voxels[voxel].value = 3;\n  }\n}\n`;class K{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:H({chunkSize:e})})}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.grass||(n.bindings.grass=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.grass),e.dispatchWorkgroups(o.x,o.y,o.z)}}const J=({chunkSize:e})=>`\n${G.compute({atomicBounds:!0,atomicQueueCount:!0,chunkSize:e})}\n\n${P}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += simplexNoise3(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n@group(0) @binding(0) var<storage, read_write> bounds : Bounds;\n@group(0) @binding(1) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(2) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n\n  if (pos.y == chunkSize.y - 1) {\n    let voxel = getVoxel(pos);\n    chunk.voxels[voxel].light = maxLight;\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n    return;\n  }\n\n  let wpos = vec3<f32>(position + pos);\n  if (wpos.y == 0 || wpos.y <= abs(FBM(wpos * 0.02) + 0.2) * f32(chunkSize.y) * 1.5) {\n    var value : u32;\n    if (abs(FBM(wpos.yzx * vec3<f32>(0.01, 0.04, 0.01))) > 0.4) {\n      value = 1;\n    } else {\n      value = 2;\n    }\n    chunk.voxels[getVoxel(pos)].value = value;\n    atomicMin(&bounds.min[0], u32(pos.x));\n    atomicMin(&bounds.min[1], u32(pos.y));\n    atomicMin(&bounds.min[2], u32(pos.z));\n    atomicMax(&bounds.max[0], u32(pos.x) + 1);\n    atomicMax(&bounds.max[1], u32(pos.y) + 1);\n    atomicMax(&bounds.max[2], u32(pos.z) + 1);\n  }\n}\n`;class Z{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:J({chunkSize:e})}),entryPoint:"main"}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.terrain||(n.bindings.terrain=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.bounds}},{binding:1,resource:{buffer:n.data}},{binding:2,resource:{buffer:n.offset}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.terrain),e.dispatchWorkgroups(o.x,o.y,o.z)}}class ee{constructor({chunkSize:e,device:n}){this.grass=new K({chunkSize:e,device:n}),this.terrain=new Z({chunkSize:e,device:n})}compute(e,n){const{grass:t,terrain:i}=this;i.compute(e,n),t.compute(e,n)}}const ne=[p(1,0),p(-1,0),p(0,1),p(0,-1)],te=d();class ie{constructor({chunkSize:e={x:64,y:64,z:64},camera:n,device:t}){this.chunkSize=e,this.device=t,this.chunks={data:new Map,loaded:[]},this.frustum=new C({device:t,camera:n}),this.lighting=new I({chunkSize:e,device:t}),this.mesher=new Y({chunkSize:e,device:t,frustum:this.frustum}),this.projectiles=new Q({chunkSize:e,device:t}),this.worldgen=new ee({chunkSize:e,device:t})}compute(e,n){const{chunks:t,frustum:i,lighting:o,mesher:r,projectiles:a,worldgen:s}=this,u=e.beginComputePass();a.step(u,n),t.loaded.forEach((e=>{e.hasGenerated||(e.hasGenerated=!0,s.compute(u,e)),e.neighbors||(e.neighbors=ne.map((n=>{const t=this.get(v(te,e.position,n));return t.hasGenerated||s.compute(u,t),t}))),a.compute(u,e)})),t.loaded.forEach((e=>o.compute(u,e))),i.compute(u),t.loaded.forEach((e=>r.compute(u,e))),u.end()}get(e){const{chunks:n,chunkSize:t,device:i}=this,o=`${e[0]}:${e[1]}`;let r=n.data.get(o);return r||(r=new G({chunkSize:t,device:i,position:e}),n.data.set(o,r)),r}load(e,n,t){const{chunks:i}=this;for(let n=0,u=i.loaded.length;n<u;n++){const c=i.loaded[n];o=e,r=c.position,a=void 0,s=void 0,a=r[0]-o[0],s=r[1]-o[1],Math.hypot(a,s)>t-.5&&(i.loaded.splice(n,1),n--,u--)}var o,r,a,s;ie.getGrid(n).forEach((n=>{const t=this.get(v(te,e,n));i.loaded.includes(t)||i.loaded.push(t)}))}static getGrid(e){let n=ie.grids.get(e);if(!n){n=[];for(let t=-e;t<=e;t++)for(let i=-e;i<=e;i++){f(te,i,t);const o=g(te);o<=e-.5&&n.push({distance:o,position:l(te)})}n.sort((({distance:e},{distance:n})=>e-n)),n=n.map((({position:e})=>e)),ie.grids.set(e,n)}return n}}ie.grids=new Map;(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const n=await e.requestDevice(),t=n.createShaderModule({code:"const checkConstSupport : f32 = 1;"}),{messages:i}=await t.compilationInfo();if(i.find((({type:e})=>"error"===e)))throw new Error("WGSL const support");return{adapter:e,device:n}})().then((({adapter:n,device:t})=>{const i=new x({device:t}),o=new ie({camera:i,device:t}),a=new M({adapter:n,camera:i,device:t});document.getElementById("renderer").appendChild(a.canvas),a.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>a.setSize(window.innerWidth,window.innerHeight)),!1);const c=new S({instances:o.projectiles.instances,camera:i,device:t,samples:a.samples});a.scene.push(c);const l=new T({camera:i,chunks:o.chunks.loaded,device:t,samples:a.samples,sunlight:a.sunlight});l.atlas.compute(),l.atlas.setupDragAndDrop(),a.scene.push(l);const v=new w({position:s(i.position,0,.5*o.chunkSize.y,0),target:a.canvas}),g=new E({renderer:a,voxels:l}),m=d(),k=p(o.chunkSize.x,o.chunkSize.z),y=p(-1,-1),b=r();let z=performance.now()/1e3,_=z;document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(z=performance.now()/1e3)}),!1);const P=()=>{requestAnimationFrame(P);const n=performance.now()/1e3,r=Math.min(n-z,1);var s,c,d;z=n,v.update(r),g.update(r),s=i.target,c=i.position,d=v.vectors.forward,s[0]=c[0]+d[0],s[1]=c[1]+d[1],s[2]=c[2]+d[2],i.updateView(),function(e,n){e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1])}(m,function(e,n,t){return e[0]=n[0]/t[0],e[1]=n[1]/t[1],e}(m,f(m,i.position[0],i.position[2]),k)),function(n,t){var i=n[0],o=n[1],r=t[0],a=t[1];return Math.abs(i-r)<=e*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(o-a)<=e*Math.max(1,Math.abs(o),Math.abs(a))}(y,m)||(h(y,m),o.load(m,4,5)),v.buttons.primary&&n-_>.05&&(_=n,o.projectiles.shoot(v.vectors.forward,u(b,i.position,v.vectors.forward,.5)));const l=t.createCommandEncoder();o.compute(l,r),a.render(l),t.queue.submit([l.finish()])};requestAnimationFrame(P)})).catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
