!function(){"use strict";var e=1e-6,n="undefined"!=typeof Float32Array?Float32Array:Array,t=Math.PI/180;function i(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var o=function(e,n,t,i,o){var r,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e};function r(){var e=new n(3);return n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,t,i){var o=new n(3);return o[0]=e,o[1]=t,o[2]=i,o}function s(e,n,t,i){return e[0]=n,e[1]=t,e[2]=i,e}function u(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e}function c(){var e=new n(2);return n!=Float32Array&&(e[0]=0,e[1]=0),e}function p(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t}function d(e,t){var i=new n(2);return i[0]=e,i[1]=t,i}function l(e,n){return e[0]=n[0],e[1]=n[1],e}function h(e,n,t){return e[0]=n,e[1]=t,e}function f(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e}function v(e){var n=e[0],t=e[1];return Math.hypot(n,t)}r(),function(){var e=c()}();const g=a(0,1,0);class m{constructor({device:e,aspect:n=1,fov:t=75,near:o=.1,far:a=1e3}){this.device=e,this.buffer=e.createBuffer({size:32*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=n,this.fov=t,this.near=o,this.far=a,this.projectionMatrix=i(),this.viewMatrix=i(),this.position=r(),this.target=r()}updateProjection(){const{device:e,buffer:n,projectionMatrix:i,aspect:r,fov:a,near:s,far:u}=this;o(i,a*t,r,s,u),e.queue.writeBuffer(n,0,i)}updateView(){const{device:n,buffer:t,viewMatrix:i,position:o,target:r}=this;var a,s,u,c,p,d,l,h,f,v,m,x,k,y,w,b,z,S,E,M,_,P,B;a=i,u=r,c=g,w=(s=o)[0],b=s[1],z=s[2],S=c[0],E=c[1],M=c[2],_=u[0],P=u[1],B=u[2],Math.abs(w-_)<e&&Math.abs(b-P)<e&&Math.abs(z-B)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(m=w-_,x=b-P,k=z-B,p=E*(k*=y=1/Math.hypot(m,x,k))-M*(x*=y),d=M*(m*=y)-S*k,l=S*x-E*m,(y=Math.hypot(p,d,l))?(p*=y=1/y,d*=y,l*=y):(p=0,d=0,l=0),h=x*l-k*d,f=k*p-m*l,v=m*d-x*p,(y=Math.hypot(h,f,v))?(h*=y=1/y,f*=y,v*=y):(h=0,f=0,v=0),a[0]=p,a[1]=h,a[2]=m,a[3]=0,a[4]=d,a[5]=f,a[6]=x,a[7]=0,a[8]=l,a[9]=v,a[10]=k,a[11]=0,a[12]=-(p*w+d*b+l*z),a[13]=-(h*w+f*b+v*z),a[14]=-(m*w+x*b+k*z),a[15]=1),n.queue.writeBuffer(t,64,i)}}const x=r(),k=c(),y=r();class w{constructor({position:e,target:t}){var i,o;this.target=t,this.gamepad=null,this.keyboard=r(),this.pointer={movement:c(),position:c()},this.look={state:d(.5*Math.PI,0),target:d(.5*Math.PI,0)},this.position={state:e,target:(i=e,o=new n(3),o[0]=i[0],o[1]=i[1],o[2]=i[2],o)},this.speed={state:8,target:8},this.vectors={forward:r(),right:r(),worldUp:a(0,1,0)},t.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnected.bind(this),!1),window.addEventListener("gamepadconnected",this.onGamepadConnected.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),t.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}lock(){const{isLocked:e,target:n}=this;e||n.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onGamepadDisconnected({gamepad:{index:e}}){const{gamepad:n}=this;n===e&&(this.gamepad=null)}onGamepadConnected({gamepad:{index:e}}){this.gamepad=e}onKeyDown({key:e,repeat:n,target:t}){const{isLocked:i,keyboard:o}=this;if(i&&!n&&"INPUT"!==t.tagName)switch(e.toLowerCase()){case"w":o[2]=1;break;case"s":o[2]=-1;break;case"a":o[0]=-1;break;case"d":o[0]=1;break;case" ":o[1]=1;break;case"shift":o[1]=-1}}onKeyUp({key:e}){const{isLocked:n,keyboard:t}=this;if(n)switch(e.toLowerCase()){case"w":t[2]>0&&(t[2]=0);break;case"s":t[2]<0&&(t[2]=0);break;case"a":t[0]<0&&(t[0]=0);break;case"d":t[0]>0&&(t[0]=0);break;case" ":t[1]>0&&(t[1]=0);break;case"shift":t[1]<0&&(t[1]=0)}}onMouseDown({button:e}){const{isLocked:n,pointer:t}=this;n?t.isDown=0===e:this.lock()}onMouseMove({clientX:e,clientY:n,movementX:t,movementY:i}){const{sensitivity:o}=w,{isLocked:r,pointer:{movement:a,position:s}}=this;r&&(a[0]-=t*o.pointer,a[1]+=i*o.pointer,h(s,e/window.innerWidth*2-1,-n/window.innerHeight*2+1))}onMouseUp({button:e}){const{isLocked:n,pointer:t}=this;n&&0===e&&(t.isDown=!1)}onMouseWheel(e){const{sensitivity:n,minSpeed:t,speedRange:i}=w,{isLocked:o,speed:r}=this;if(e.ctrlKey&&e.preventDefault(),!o)return;const a=Math.min(Math.max((Math.log(r.target)-t)/i-e.deltaY*n.wheel,0),1);r.target=Math.exp(t+a*i)}onPointerLock(){const{keyboard:e,pointer:n}=this;this.isLocked=!!document.pointerLockElement,this.isLocked||(s(e,0,0,0),n.isDown=!1)}update(e){const{minPhi:n,maxPhi:t,sensitivity:i}=w,{isLocked:o,gamepad:r,keyboard:a,pointer:c,look:p,position:d,speed:f,vectors:v}=this;if(o){if(m=a,(g=y)[0]=m[0],g[1]=m[1],g[2]=m[2],l(k,c.movement),null!==r){const{axes:e}=navigator.getGamepads()[r];Math.max(Math.abs(e[2]),Math.abs(e[3]))>.1&&h(k,-e[2]*i.gamepad,-e[3]*i.gamepad),Math.max(Math.abs(e[0]),Math.abs(e[1]))>.1&&s(y,e[0],0,-e[1])}p.target[0]=Math.min(Math.max(p.target[0]+k[1],n),t),p.target[1]+=k[0]}var g,m;h(c.movement,0,0);const b=1-Math.exp(-20*e);if(function(e,n,t,i){var o=n[0],r=n[1];e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r)}(p.state,p.state,p.target,b),f.state=f.state*(1-b)+f.target*b,s(v.forward,Math.sin(p.state[0])*Math.sin(p.state[1]),Math.cos(p.state[0]),Math.sin(p.state[0])*Math.cos(p.state[1])),function(e,n,t){var i=n[0],o=n[1],r=n[2],a=t[0],s=t[1],u=t[2];e[0]=o*u-r*s,e[1]=r*a-i*u,e[2]=i*s-o*a}(v.right,v.forward,v.worldUp),0!==y[0]||0!==y[1]||0!==y[2]){s(x,0,0,0),u(x,x,v.right,y[0]),u(x,x,v.worldUp,y[1]),u(x,x,v.forward,y[2]),s(y,0,0,0);const n=function(e){var n=e[0],t=e[1],i=e[2];return Math.hypot(n,t,i)}(x);n>1&&function(e,n,t){e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t}(x,x,1/n),u(d.target,d.target,x,e*f.state)}!function(e,n,t,i){var o=n[0],r=n[1],a=n[2];e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r),e[2]=a+i*(t[2]-a)}(d.state,d.state,d.target,1-Math.exp(-10*e))}}w.sensitivity={gamepad:.03,pointer:.003,wheel:3e-4},w.minPhi=.01,w.maxPhi=Math.PI-.01,w.minSpeed=Math.log(4),w.maxSpeed=Math.log(32),w.speedRange=w.maxSpeed-w.minSpeed;class b{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const n=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}],entryPoint:"main",module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"})},fragment:{entryPoint:"main",module:e.createShaderModule({code:"\n@group(0) @binding(0) var colorTexture : texture_2d<f32>;\n@group(0) @binding(1) var dataTexture : texture_2d<f32>;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.1;\nconst depthScale : f32 = 0.5;\nconst normalScale : f32 = 0.5;\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edge(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  var pixelLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  var pixelRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  var pixelUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  var pixelDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  var edge : vec4<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return clamp(max((edge.x + edge.y + edge.z) * normalScale, edge.w * depthScale), 0, 1);\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  var pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, edgeColor, edge(pixel) * edgeIntensity);\n  return vec4<f32>(color, 1);\n}\n"}),targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures([e,n]){const{device:t,pipeline:i}=this;this.bindings=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:e.resolveTarget},{binding:1,resource:n.resolveTarget}]})}render(e,n){const{bindings:t,descriptor:i,geometry:o,pipeline:r}=this;i.colorAttachments[0].view=n;const a=e.beginRenderPass(i);a.setPipeline(r),a.setBindGroup(0,t),a.setVertexBuffer(0,o),a.draw(6,1,0,0),a.end()}}var z="\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const S=({count:e,width:n,height:t,generator:i})=>`\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${z}\n\n${i}\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class E{constructor({device:e,count:n=3,width:t=16,height:i=16}){this.device=e,this.count=n,this.width=t,this.height=i,this.texture=e.createTexture({dimension:"2d",size:[t,i,n],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.workgroups=Math.ceil(n*t*i/256)}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  if (texture == 0 || (texture == 2 && pixel.y > 4 - i32(4 * noise3(vec3<f32>(vec2<f32>(pixel), 0))))) {\n    return vec4<f32>(1);\n  }\n  return vec4<f32>(0.6, 1.0, 0.6, 1.0);\n}\n"){const{device:n,count:t,width:i,height:o,texture:r,workgroups:a}=this,s=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:S({count:t,width:i,height:o,generator:e})})}}),u=n.createCommandEncoder(),c=u.beginComputePass();c.setPipeline(s),c.setBindGroup(0,n.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:r.createView()}]})),c.dispatchWorkgroups(a),c.end(),n.queue.submit([u.finish()])}}class M{constructor({camera:e,device:n,samples:t}){this.atlas=new E({device:n}),this.geometry=(e=>{const n=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n})(n),this.pipeline=n.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:4,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:5,offset:5*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:n.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) light : f32,\n  @location(4) face : f32,\n  @location(5) texture : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\nconst sunlightColor : vec3<f32> = vec3<f32>(0.9, 0.8, 0.4);\nconst PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (i32(voxel.face)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var mvPosition : vec4<f32> = camera.view * vec4<f32>(rotation * voxel.position + voxel.origin, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.depth = -mvPosition.z;\n  out.light = sunlightColor * pow(voxel.light, 8);\n  out.texture = i32(voxel.texture);\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.color *= vec4<f32>(face.light, 1);\n  output.data = vec4<f32>(normalize(face.normal), face.depth);\n  return output;\n}\n"}),targets:[{format:"rgba8unorm"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:t}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:n.createSampler()}]})}render(e,n){const{bindings:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setVertexBuffer(0,i),n.forEach((({faces:n})=>{e.setVertexBuffer(1,n,16),e.drawIndirect(n,0)}))}}class _{constructor({adapter:e,camera:n,device:t,samples:i=4}){const o=navigator.gpu.getPreferredCanvasFormat(e);this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:o}),this.camera=n,this.device=t,this.samples=i,this.textures=new Map,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.postprocessing=new b({device:t,format:o}),this.voxels=new M({camera:n,device:t,samples:i})}render(e,n){const{context:t,descriptor:i,postprocessing:o,voxels:r}=this,a=e.beginRenderPass(i);r.render(a,n),a.end(),o.render(e,t.getCurrentTexture().createView())}setClearColor(e,n,t){const{descriptor:{colorAttachments:[{clearValue:i}]}}=this;i.r=e,i.g=n,i.b=t}setSize(e,n){const{camera:t,canvas:i,descriptor:o,postprocessing:r}=this,a=window.devicePixelRatio||1,s=[Math.floor(e*a),Math.floor(n*a)];i.width=s[0],i.height=s[1],i.style.width=`${e}px`,i.style.height=`${n}px`,t.aspect=e/n,t.updateProjection(),this.updateTexture(o.colorAttachments[0],"rgba8unorm","color",s),this.updateTexture(o.colorAttachments[1],"rgba16float","data",s),this.updateTexture(o.depthStencilAttachment,"depth24plus","depth",s,!1),r.bindTextures(o.colorAttachments)}updateTexture(e,n,t,i,o=!0){const{device:r,samples:a,textures:s}=this,u=s.get(t);u&&u.forEach((e=>e.destroy())),s.set(t,[a,...o?[1]:[]].map((t=>{const o=r.createTexture({format:n,sampleCount:t,size:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|(1===t?GPUTextureUsage.TEXTURE_BINDING:0)});return 1===t?e.resolveTarget=o.createView():e.view=o.createView(),o})))}}class P{constructor({chunkSize:e,device:n,position:t}){this.bindings={},this.position=p(t),this.data=n.createBuffer({mappedAtCreation:!0,size:(6+e.x*e.y*e.z+e.x*e.y*e.z+1+1+2*(1+e.x*e.z*3))*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.data.getMappedRange(0,3*Uint32Array.BYTES_PER_ELEMENT)).set([e.x,e.y,e.z]),this.data.unmap(),this.faces=n.createBuffer({size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(e.x*e.y*e.z*.5)*6*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),this.offset=n.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.offset.getMappedRange()).set([t[0]*e.x,0,t[1]*e.z]),this.offset.unmap()}}P.compute=({atomicBounds:e,atomicInstanceCount:n,atomicLight:t,atomicQueueCount:i,chunkSize:o})=>`\n  const chunkSize : vec3<i32> = vec3<i32>(${o.x}, ${o.y}, ${o.z});\n  const maxLight : u32 = 255;\n\n  struct Bounds {\n    min : array<${e?"atomic<u32>":"u32"}, 3>,\n    max : array<${e?"atomic<u32>":"u32"}, 3>,\n  }\n\n  struct Faces {\n    vertexCount : u32,\n    instanceCount : ${n?"atomic<u32>":"u32"},\n    firstVertex : u32,\n    firstInstance : u32,\n    data : array<f32>,\n  }\n\n  struct Queue {\n    count : ${i?"atomic<u32>":"u32"},\n    data : array<u32, ${o.x*o.z*3}>,\n  }\n\n  struct Chunk {\n    bounds : Bounds,\n    voxels : array<u32, ${o.x*o.y*o.z}>,\n    light : array<${t?"atomic<u32>":"u32"}, ${o.x*o.y*o.z}>,\n    remesh : u32,\n    queue : u32,\n    queues : array<Queue, 2>,\n  }\n\n  fn getVoxel(pos : vec3<i32>) -> u32 {\n    return u32(pos.z * chunkSize.x * chunkSize.y + pos.y * chunkSize.x + pos.x);\n  }\n\n  fn getPos(voxel : u32) -> vec3<i32> {\n    var o : i32 = i32(voxel) % (chunkSize.x * chunkSize.y);\n    return vec3<i32>(\n      o % chunkSize.x,\n      o / chunkSize.x,\n      i32(voxel) / (chunkSize.x * chunkSize.y),\n    );\n  }\n`;class B{constructor({device:e,camera:n}){this.buffer=e.createBuffer({size:24*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),this.pipeline=e.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:e.createShaderModule({code:"\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<storage, read_write> frustum : array<vec4<f32>, 6>;\n\nfn update(index : i32, plane : vec4<f32>) {\n  frustum[index] = plane * (1 / length(plane.xyz));\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  var m : mat4x4<f32> = camera.projection * camera.view;\n  update(0, vec4<f32>(m[0].w - m[0].x, m[1].w - m[1].x, m[2].w - m[2].x, m[3].w - m[3].x));\n  update(1, vec4<f32>(m[0].w + m[0].x, m[1].w + m[1].x, m[2].w + m[2].x, m[3].w + m[3].x));\n  update(2, vec4<f32>(m[0].w + m[0].y, m[1].w + m[1].y, m[2].w + m[2].y, m[3].w + m[3].y));\n  update(3, vec4<f32>(m[0].w - m[0].y, m[1].w - m[1].y, m[2].w - m[2].y, m[3].w - m[3].y));\n  update(4, vec4<f32>(m[0].w - m[0].z, m[1].w - m[1].z, m[2].w - m[2].z, m[3].w - m[3].z));\n  update(5, vec4<f32>(m[0].w + m[0].z, m[1].w + m[1].z, m[2].w + m[2].z, m[3].w + m[3].z));\n}\n"})}}),this.bindings=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:this.buffer}}]})}compute(e){const{bindings:n,pipeline:t}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(1)}}const G=({chunkSize:e})=>`\n${P.compute({atomicQueueCount:!0,atomicLight:!0,chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n\nfn flood(pos : vec3<i32>, level : u32) {\n  // I really tried to make this with pointers\n  // and a single logic block but I couldn't manage to\n  // pass a ptr<storage, Chunk, read_write> to a function\n  if (pos.x == -1) {\n    var voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (chunk_west.voxels[voxel] != 0) {\n      chunk_west.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_west.light[voxel], level) < level) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&(chunk_west.queues[chunk_west.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    var voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (chunk_east.voxels[voxel] != 0) {\n      chunk_east.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_east.light[voxel], level) < level) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&(chunk_east.queues[chunk_east.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    var voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (chunk_south.voxels[voxel] != 0) {\n      chunk_south.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_south.light[voxel], level) < level) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&(chunk_south.queues[chunk_south.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    var voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (chunk_north.voxels[voxel] != 0) {\n      chunk_north.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_north.light[voxel], level) < level) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&(chunk_north.queues[chunk_north.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  var voxel : u32 = getVoxel(pos);\n  if (chunk.voxels[voxel] != 0) {\n    return;\n  }\n  if (atomicMax(&chunk.light[voxel], level) < level) {\n    chunk.queues[chunk.queue].data[atomicAdd(&(chunk.queues[chunk.queue].count), 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  if (GlobalInvocationID.x >= uniforms.count) {\n    return;\n  }\n  var voxel : u32 = chunk.queues[uniforms.queue].data[GlobalInvocationID.x];\n  var light : u32 = atomicLoad(&chunk.light[voxel]);\n  var pos : vec3<i32> = getPos(voxel);\n  for (var n : i32 = 0; n < 6; n++) {\n    var npos = pos + neighbors[n];\n    if (npos.y == -1 || npos.y == chunkSize.y) {\n      continue;\n    }\n    var level : u32 = light;\n    if (n != 0 || level < maxLight) {\n      level -= 1;\n    }\n    flood(npos, level);\n  }\n}\n`;class C{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:G({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups=i}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.lightingCompute||(n.bindings.lightingCompute=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingCompute),e.dispatchWorkgroupsIndirect(r,0)}}const L=({chunkSize:e})=>`\n${P.compute({chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> uniforms : Uniforms;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n\n@compute @workgroup_size(1)\nfn main() {\n  var count : u32 = chunk.queues[chunk.queue].count;\n  if (count == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n\n  uniforms.count = count;\n  uniforms.queue = chunk.queue;\n\n  workgroups[0] = u32(ceil(f32(count) / 64));\n  workgroups[1] = 1;\n  workgroups[2] = 1;\n\n  var next : u32 = (chunk.queue + 1) % 2;\n  chunk.queue = next;\n  chunk.queues[next].count = 0;\n\n  chunk.remesh = 1;\n}\n`;class T{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:L({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.lightingSetup||(n.bindings.lightingSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingSetup),e.dispatchWorkgroups(1)}}class I{constructor({chunkSize:e,device:n}){const t=n.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.propagate=new C({chunkSize:e,device:n,uniforms:t,workgroups:i}),this.setup=new T({chunkSize:e,device:n,uniforms:t,workgroups:i})}compute(e,n){const{propagate:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const A=({chunkSize:e})=>`\n${P.compute({atomicInstanceCount:!0,chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read> chunk : Chunk;\n@group(0) @binding(1) var<storage, read> chunk_east : Chunk;\n@group(0) @binding(2) var<storage, read> chunk_west : Chunk;\n@group(0) @binding(3) var<storage, read> chunk_north : Chunk;\n@group(0) @binding(4) var<storage, read> chunk_south : Chunk;\n@group(0) @binding(5) var<storage, read_write> faces : Faces;\n@group(0) @binding(6) var<uniform> position : vec3<i32>;\n\nfn isAir(pos : vec3<i32>) -> bool {\n  if (\n    pos.y < 0\n    || (pos.x < 0 && pos.z < 0)\n    || (pos.x >= chunkSize.x && pos.z < 0)\n    || (pos.x < 0 && pos.z >= chunkSize.z)\n    || (pos.x >= chunkSize.x && pos.z >= chunkSize.z)\n  ) {\n    return false;\n  }\n  if (pos.y >= chunkSize.y) {\n    return true;\n  }\n  if (pos.x < 0) {\n    return chunk_west.voxels[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))] == 0;\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.voxels[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))] == 0;\n  }\n  if (pos.z < 0) {\n    return chunk_south.voxels[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))] == 0;\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.voxels[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))] == 0;\n  }\n  return chunk.voxels[getVoxel(pos)] == 0;\n}\n\nfn getLight(pos : vec3<i32>) -> u32 {\n  if (pos.y < 0) {\n    return 0;\n  }\n  if (pos.y >= chunkSize.y) {\n    return maxLight;\n  }\n  if (pos.x < 0) {\n    return chunk_west.light[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.light[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.z < 0) {\n    return chunk_south.light[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))];\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.light[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))];\n  }\n  return chunk.light[getVoxel(pos)]; \n}\n\nstruct Normals {\n  f : vec3<i32>,\n  u : vec3<i32>,\n  v : vec3<i32>,\n}\n\nconst faceNormals = array<Normals, 6>(\n  Normals(vec3<i32>(0, 0, 1), vec3<i32>(0, 1, 0), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, 1, 0), vec3<i32>(0, 0, -1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, -1, 0), vec3<i32>(0, 0, 1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(-1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(0, 0, -1), vec3<i32>(0, 1, 0), vec3<i32>(-1, 0, 0)),\n);\n\nconst neighbors = array<vec2<i32>, 5>(\n  vec2<i32>(0, 0),\n  vec2<i32>(-1, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, -1),\n  vec2<i32>(0, 1),\n);\n\nfn getLightAvg(pos : vec3<i32>, u : vec3<i32>, v : vec3<i32>) -> f32 {\n  var level : f32;\n  var count : i32;\n  for (var n : i32 = 0; n < 5; n++) {\n    var nuv = neighbors[n];\n    var npos : vec3<i32> = pos + u * nuv.x + v * nuv.y;\n    if (n == 0 || isAir(npos)) {\n      var nlight : u32 = getLight(npos);\n      if (nlight != 0) {\n        level += f32(nlight);\n        count++;\n      }\n    }\n  }\n  return level / f32(max(count, 1)) / f32(maxLight);\n}\n\nfn getTexture(face : i32, value : u32) -> i32 {\n  if (value == 1 || face == 2) {\n    return 0;\n  }\n  if (value == 2 && face == 1) {\n    return 1;\n  }\n  return 2;\n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32, light : f32) {\n  if (light == 0) {\n    return;\n  }\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 6;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = light;\n  faces.data[offset + 4] = f32(face);\n  faces.data[offset + 5] = f32(texture);\n}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  var value : u32 = chunk.voxels[getVoxel(pos)];\n  if (value != 0) {\n    for (var face : i32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face].f;\n      if (isAir(npos)) {\n        pushFace(\n          position + pos,\n          face,\n          getTexture(face, value),\n          getLightAvg(npos, faceNormals[face].u, faceNormals[face].v)\n        );\n      }\n    }\n  }\n}\n`;class U{constructor({chunkSize:e,device:n,workgroups:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:A({chunkSize:e})}),entryPoint:"main"}}),this.workgroups=t}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.mesherCompute||(n.bindings.mesherCompute=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[n,...n.neighbors,{data:n.faces},{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(i),e.setBindGroup(0,n.bindings.mesherCompute),e.dispatchWorkgroupsIndirect(o,0)}}const R=({chunkSize:e})=>`\n${P.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<uniform> frustum : array<vec4<f32>, 6>;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> faces : Faces;\n@group(1) @binding(2) var<uniform> position : vec3<i32>;\n\nfn isInFrustum() -> bool {\n  var corner : vec3<f32>;\n  var origin : vec3<f32> = vec3<f32>(position);\n  for (var i : i32 = 0; i < 6; i++) {\n    var plane : vec4<f32> = frustum[i];\n    for (var j : i32 = 0; j < 3; j++) {\n      if (plane[j] > 0) {\n        corner[j] = f32(chunk.bounds.max[j]);\n      } else {\n        corner[j] = f32(chunk.bounds.min[j]);\n      }\n    }\n    if ((dot(plane.xyz, origin + corner) + plane.w) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  if (isInFrustum()) {\n    faces.vertexCount = 6;\n  } else {\n    faces.vertexCount = 0;\n  }\n  if (chunk.remesh == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n  chunk.remesh = 0;\n  faces.instanceCount = 0;\n  workgroups[0] = u32(ceil(f32(chunkSize.x) / 4));\n  workgroups[1] = u32(ceil(f32(chunkSize.y) / 4));\n  workgroups[2] = u32(ceil(f32(chunkSize.z) / 4));\n}\n`;class q{constructor({chunkSize:e,device:n,frustum:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:R({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.mesherSetup||(n.bindings.mesherSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.faces}},{binding:2,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.mesherSetup),e.dispatchWorkgroups(1)}}class N{constructor({chunkSize:e,device:n,frustum:t}){const i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.mesh=new U({chunkSize:e,device:n,workgroups:i}),this.setup=new q({chunkSize:e,device:n,frustum:t,workgroups:i})}compute(e,n){const{mesh:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const V=({chunkSize:e})=>`\n${P.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  var voxel = getVoxel(pos);\n  if (chunk.voxels[voxel] == 1 && chunk.voxels[getVoxel(pos + vec3<i32>(0, 1, 0))] == 0) {\n    chunk.voxels[voxel] = 2;\n  }\n}\n`;class F{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:V({chunkSize:e})})}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.grass||(n.bindings.grass=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.grass),e.dispatchWorkgroups(o.x,o.y,o.z)}}const D=({chunkSize:e})=>`\n${P.compute({atomicBounds:!0,atomicQueueCount:!0,chunkSize:e})}\n\n${z}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += simplexNoise3(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n\n  if (pos.y == chunkSize.y - 1) {\n    var voxel = getVoxel(pos);\n    chunk.light[voxel] = maxLight;\n    chunk.queues[chunk.queue].data[atomicAdd(&(chunk.queues[chunk.queue].count), 1)] = voxel;\n    return;\n  }\n\n  var wpos = vec3<f32>(position + pos);\n  if (wpos.y == 0 || wpos.y <= abs(FBM(wpos * 0.02) + 0.2) * f32(chunkSize.y) * 1.5) {\n    chunk.voxels[getVoxel(pos)] = 1;\n    atomicMin(&chunk.bounds.min[0], u32(pos.x)); \n    atomicMin(&chunk.bounds.min[1], u32(pos.y)); \n    atomicMin(&chunk.bounds.min[2], u32(pos.z));\n    atomicMax(&chunk.bounds.max[0], u32(pos.x) + 1); \n    atomicMax(&chunk.bounds.max[1], u32(pos.y) + 1); \n    atomicMax(&chunk.bounds.max[2], u32(pos.z) + 1);\n  }\n}\n`;class ${constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:D({chunkSize:e})}),entryPoint:"main"}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.terrain||(n.bindings.terrain=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.offset}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.terrain),e.dispatchWorkgroups(o.x,o.y,o.z)}}class Y{constructor({chunkSize:e,device:n}){this.grass=new F({chunkSize:e,device:n}),this.terrain=new $({chunkSize:e,device:n})}compute(e,n){const{grass:t,terrain:i}=this;i.compute(e,n),t.compute(e,n)}}const O=[d(1,0),d(-1,0),d(0,1),d(0,-1)],j=c();class W{constructor({chunkSize:e={x:64,y:64,z:64},camera:n,device:t}){this.chunkSize=e,this.device=t,this.chunks={data:new Map,loaded:[]},this.frustum=new B({device:t,camera:n}),this.lighting=new I({chunkSize:e,device:t}),this.mesher=new N({chunkSize:e,device:t,frustum:this.frustum}),this.worldgen=new Y({chunkSize:e,device:t})}compute(e){const{chunks:n,frustum:t,lighting:i,mesher:o,worldgen:r}=this,a=e.beginComputePass();t.compute(a),n.loaded.forEach((e=>{e.hasGenerated||(e.hasGenerated=!0,r.compute(a,e)),e.neighbors||(e.neighbors=O.map((n=>{const t=this.get(f(j,e.position,n));return t.hasGenerated||r.compute(a,t),t}))),i.compute(a,e),o.compute(a,e)})),a.end()}get(e){const{chunks:n,chunkSize:t,device:i}=this,o=`${e[0]}:${e[1]}`;let r=n.data.get(o);return r||(r=new P({chunkSize:t,device:i,position:e}),n.data.set(o,r)),r}load(e,n,t){const{chunks:i}=this;for(let n=0,u=i.loaded.length;n<u;n++){const c=i.loaded[n];o=e,r=c.position,a=void 0,s=void 0,a=r[0]-o[0],s=r[1]-o[1],Math.hypot(a,s)>t-.5&&(i.loaded.splice(n,1),n--,u--)}var o,r,a,s;W.getGrid(n).forEach((n=>{const t=this.get(f(j,e,n));i.loaded.includes(t)||i.loaded.push(t)}))}static getGrid(e){let n=W.grids.get(e);if(!n){n=[];for(let i=-e;i<=e;i++)for(let o=-e;o<=e;o++){h(j,o,i);var t=v(j);t<=e-.5&&n.push({distance:t,position:p(j)})}n.sort((({distance:e},{distance:n})=>e-n)),n=n.map((({position:e})=>e)),W.grids.set(e,n)}return n}}W.grids=new Map;(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const n=await e.requestDevice(),t=n.createShaderModule({code:"const checkConstSupport : f32 = 1;"}),{messages:i}=await t.compilationInfo();if(i.find((({type:e})=>"error"===e)))throw new Error("WGSL const support");return{adapter:e,device:n}})().then((({adapter:n,device:t})=>{const i=new m({device:t}),o=new W({camera:i,device:t}),r=new _({adapter:n,camera:i,device:t});document.getElementById("renderer").appendChild(r.canvas),r.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>r.setSize(window.innerWidth,window.innerHeight)),!1),r.setClearColor(.2,.6,.6),s(i.position,0,.5*o.chunkSize.y,0);let a=performance.now()/1e3;document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(a=performance.now()/1e3)}),!1);const u=new w({position:i.position,target:document.getElementById("renderer")}),p=c(),f=d(o.chunkSize.x,o.chunkSize.z),v=d(-1,-1),g=()=>{requestAnimationFrame(g);const n=performance.now()/1e3,s=Math.min(n-a,1);var c,d,m;a=n,u.update(s),function(e,n){e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1])}(p,(c=p,d=h(p,i.position[0],i.position[2]),m=f,c[0]=d[0]/m[0],c[1]=d[1]/m[1],c)),function(n,t){var i=n[0],o=n[1],r=t[0],a=t[1];return Math.abs(i-r)<=e*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(o-a)<=e*Math.max(1,Math.abs(o),Math.abs(a))}(v,p)||(l(v,p),o.load(p,4,5)),function(e,n,t){e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2]}(i.target,i.position,u.vectors.forward),i.updateView();const x=t.createCommandEncoder();o.compute(x),r.render(x,o.chunks.loaded),t.queue.submit([x.finish()])};r.voxels.atlas.compute(),requestAnimationFrame(g)})).catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
