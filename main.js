!function(){"use strict";var e=1e-6,n="undefined"!=typeof Float32Array?Float32Array:Array,t=Math.PI/180;function i(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var o=function(e,n,t,i,o){var r,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e};function r(){var e=new n(3);return n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e){var t=new n(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function s(e,t,i){var o=new n(3);return o[0]=e,o[1]=t,o[2]=i,o}function u(e,n){return e[0]=n[0],e[1]=n[1],e[2]=n[2],e}function c(e,n,t,i){return e[0]=n,e[1]=t,e[2]=i,e}function d(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2],e}function p(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e}function l(e,n){var t=n[0],i=n[1],o=n[2],r=t*t+i*i+o*o;return r>0&&(r=1/Math.sqrt(r)),e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e}function f(e,n,t,i){var o=n[0],r=n[1],a=n[2];return e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r),e[2]=a+i*(t[2]-a),e}function h(){var e=new n(2);return n!=Float32Array&&(e[0]=0,e[1]=0),e}function g(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t}function v(e,t){var i=new n(2);return i[0]=e,i[1]=t,i}function m(e,n){return e[0]=n[0],e[1]=n[1],e}function x(e,n,t){return e[0]=n,e[1]=t,e}function b(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e}function y(e){var n=e[0],t=e[1];return Math.hypot(n,t)}r(),function(){var e=h()}();const k=s(0,1,0);class w{constructor({device:e,aspect:n=1,fov:t=75,near:o=.1,far:a=1e3}){this.device=e,this.buffer=e.createBuffer({size:32*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=n,this.fov=t,this.near=o,this.far=a,this.projectionMatrix=i(),this.viewMatrix=i(),this.position=r(),this.target=r()}updateProjection(){const{device:e,buffer:n,projectionMatrix:i,aspect:r,fov:a,near:s,far:u}=this;o(i,a*t,r,s,u),e.queue.writeBuffer(n,0,i)}updateView(){const{device:n,buffer:t,viewMatrix:i,position:o,target:r}=this;var a,s,u,c,d,p,l,f,h,g,v,m,x,b,y,w,z,E,S,_,B,P,M;a=i,u=r,c=k,y=(s=o)[0],w=s[1],z=s[2],E=c[0],S=c[1],_=c[2],B=u[0],P=u[1],M=u[2],Math.abs(y-B)<e&&Math.abs(w-P)<e&&Math.abs(z-M)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(v=y-B,m=w-P,x=z-M,d=S*(x*=b=1/Math.hypot(v,m,x))-_*(m*=b),p=_*(v*=b)-E*x,l=E*m-S*v,(b=Math.hypot(d,p,l))?(d*=b=1/b,p*=b,l*=b):(d=0,p=0,l=0),f=m*l-x*p,h=x*d-v*l,g=v*p-m*d,(b=Math.hypot(f,h,g))?(f*=b=1/b,h*=b,g*=b):(f=0,h=0,g=0),a[0]=d,a[1]=f,a[2]=v,a[3]=0,a[4]=p,a[5]=h,a[6]=m,a[7]=0,a[8]=l,a[9]=g,a[10]=x,a[11]=0,a[12]=-(d*y+p*w+l*z),a[13]=-(f*y+h*w+g*z),a[14]=-(v*y+m*w+x*z),a[15]=1),n.queue.writeBuffer(t,64,i)}}const z=r(),E=h(),S=r(),_=r(),B=r(),P=r(),M=s(0,1,0);class T{constructor({camera:e,target:n,world:t}){this.camera=e,this.target=n,this.world=t,this.isLocked=!1,this.gamepad=null,this.keyboard={buttons:{run:!1},movement:r()},this.pointer={buttons:{primary:!1},movement:h(),position:h()},this.buttons={primary:!1},this.forward=r(),this.look={state:v(.5*Math.PI,-.5*Math.PI),target:v(.5*Math.PI,-.5*Math.PI)},this.position={target:a(e.position),targetY:e.position[1],nextTarget:a(e.position)},this.speed={state:8,target:8},n.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnected.bind(this),!1),window.addEventListener("gamepadconnected",this.onGamepadConnected.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),n.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}lock(){const{isLocked:e,target:n}=this;e||n.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onGamepadDisconnected({gamepad:{index:e}}){const{gamepad:n}=this;n===e&&(this.gamepad=null)}onGamepadConnected({gamepad:{index:e}}){this.gamepad=e}onKeyDown({key:e,repeat:n,target:t}){const{isLocked:i,keyboard:o}=this;if(i&&!n&&"INPUT"!==t.tagName)switch(e.toLowerCase()){case"w":o.movement[2]=1;break;case"s":o.movement[2]=-1;break;case"a":o.movement[0]=-1;break;case"d":o.movement[0]=1;break;case" ":o.movement[1]=1;break;case"shift":o.buttons.run=!0}}onKeyUp({key:e}){const{isLocked:n,keyboard:t}=this;if(n)switch(e.toLowerCase()){case"w":t.movement[2]>0&&(t.movement[2]=0);break;case"s":t.movement[2]<0&&(t.movement[2]=0);break;case"a":t.movement[0]<0&&(t.movement[0]=0);break;case"d":t.movement[0]>0&&(t.movement[0]=0);break;case" ":t.movement[1]>0&&(t.movement[1]=0);break;case"shift":t.buttons.run=!1}}onMouseDown({button:e}){const{isLocked:n,pointer:t}=this;n?t.buttons.primary=0===e||2===e:this.lock()}onMouseMove({clientX:e,clientY:n,movementX:t,movementY:i}){const{sensitivity:o}=T,{isLocked:r,pointer:{movement:a,position:s}}=this;r&&(a[0]-=t*o.pointer,a[1]+=i*o.pointer,x(s,e/window.innerWidth*2-1,-n/window.innerHeight*2+1))}onMouseUp({button:e}){const{isLocked:n,pointer:t}=this;!n||0!==e&&2!==e||(t.buttons.primary=!1)}onMouseWheel(e){const{sensitivity:n,minSpeed:t,speedRange:i}=T,{isLocked:o,speed:r}=this;if(e.ctrlKey&&e.preventDefault(),!o)return;const a=Math.min(Math.max((Math.log(r.target)-t)/i-e.deltaY*n.wheel,0),1);r.target=Math.exp(t+a*i)}onPointerLock(){const{buttons:e,keyboard:n,pointer:t}=this;this.isLocked=!!document.pointerLockElement,document.body.classList[this.isLocked?"add":"remove"]("pointerlock"),this.isLocked||(e.primary=!1,c(n.movement,0,0,0),n.buttons.run=!1,t.buttons.primary=!1)}update(e){const{minPhi:n,maxPhi:t,sensitivity:i}=T,{isLocked:o,buttons:r,camera:a,forward:s,gamepad:h,keyboard:g,pointer:v,look:b,position:y,speed:k}=this;let w=!1;if(o){if(w=g.buttons.run,r.primary=v.buttons.primary,u(S,g.movement),m(E,v.movement),null!==h){const{axes:e,buttons:n}=navigator.getGamepads()[h];(n[6]&&n[6].pressed||n[7]&&n[7].pressed)&&(r.primary=!0),Math.max(Math.abs(e[2]),Math.abs(e[3]))>.1&&x(E,-e[2]*i.gamepad,-e[3]*i.gamepad),Math.max(Math.abs(e[0]),Math.abs(e[1]))>.1&&c(S,e[0],0,-e[1]),(n[0]&&n[0].pressed||n[4]&&n[4].pressed||n[5]&&n[5].pressed)&&(S[1]=1),n[10]&&n[10].pressed&&(w=!0)}b.target[0]=Math.min(Math.max(b.target[0]+E[1],n),t),b.target[1]+=E[0]}x(v.movement,0,0);{const n=1-Math.exp(-20*e);_=b.state,G=b.state,L=b.target,U=n,C=G[0],A=G[1],_[0]=C+U*(L[0]-C),_[1]=A+U*(L[1]-A),k.state=k.state*(1-n)+k.target*n}var _,G,L,U,C,A;if(c(s,Math.sin(b.state[0])*Math.sin(b.state[1]),Math.cos(b.state[0]),Math.sin(b.state[0])*Math.cos(b.state[1])),0!==S[0]||0!==S[1]||0!==S[2]){const n=S[1]>0;u(B,s),n||(B[1]=0,l(B,B)),l(P,function(e,n,t){var i=n[0],o=n[1],r=n[2],a=t[0],s=t[1],u=t[2];return e[0]=o*u-r*s,e[1]=r*a-i*u,e[2]=i*s-o*a,e}(P,B,M)),c(z,0,0,0),p(z,z,P,S[0]),p(z,z,M,S[1]),p(z,z,B,S[2]),c(S,0,0,0);const t=function(e){var n=e[0],t=e[1],i=e[2];return Math.hypot(n,t,i)}(z);t>1&&function(e,n,t){e[0]=n[0]*t,e[1]=n[1]*t,e[2]=n[2]*t}(z,z,1/t),y.nextTarget[1]=y.target[1],p(y.nextTarget,y.nextTarget,z,e*k.state*(w?2:1)),n?(u(y.target,y.nextTarget),y.targetY=y.target[1]):this.updatePositionTarget()}{const n=1-Math.exp(-10*e);y.target[1]=y.target[1]*(1-n)+y.targetY*n,f(a.position,a.position,y.target,n),d(a.target,a.position,s),a.updateView()}}updatePositionTarget(){const{position:e,world:n}=this;e.isUpdating?e.needsUpdate=!0:(e.isUpdating=!0,u(_,e.nextTarget),n.getGround(_).then((n=>{if(e.isUpdating=!1,-1===n)return u(e.nextTarget,e.target),void(e.needsUpdate=!1);e.target[0]=_[0],e.target[2]=_[2],e.targetY=n+3.2,e.needsUpdate&&(e.needsUpdate=!1,this.updatePositionTarget())})))}}T.sensitivity={gamepad:.03,pointer:.003,wheel:3e-4},T.minPhi=.01,T.maxPhi=Math.PI-.01,T.minSpeed=Math.log(4),T.maxSpeed=Math.log(32),T.speedRange=T.maxSpeed-T.minSpeed;const G=r();class L{constructor(e){this.renderer=e,this.colors={background:{day:s(.032,.32,.32),night:s(.004,.004,.01)},sunlight:{day:s(1,1,.32),night:s(.01,.01,.032)}},this.target=1,this.state=0;const n=document.getElementById("light");n.classList.add("enabled");const[t,i]=n.getElementsByTagName("svg");t.addEventListener("click",(()=>{n.classList.remove("night"),n.classList.add("day"),this.target=1}),!1),i.addEventListener("click",(()=>{n.classList.remove("day"),n.classList.add("night"),this.target=0}),!1)}update(e){if(Math.abs(this.state-this.target)<.001)return;const{colors:n,renderer:t,target:i}=this,o=1-Math.exp(-10*e);this.state=this.state*(1-o)+i*o,f(G,n.background.night,n.background.day,this.state),t.setBackground(G[0],G[1],G[2]),f(G,n.sunlight.night,n.sunlight.day,this.state),t.setSunlight(G[0],G[1],G[2])}}class U{constructor({camera:e,device:n,instances:t,samples:i,sunlight:o}){this.geometry=(e=>{const n=e.createBuffer({mappedAtCreation:!0,size:36*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX}),t=new Uint16Array(n.getMappedRange());for(let e=0,n=0,i=0;e<6;e++,n+=6,i+=4)t[n]=i,t[n+1]=i+1,t[n+2]=i+2,t[n+3]=i+2,t[n+4]=i+3,t[n+5]=i;n.unmap();const i=e.createBuffer({mappedAtCreation:!0,size:144*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(i.getMappedRange()).set([-.1,-.1,.1,0,0,1,.1,-.1,.1,0,0,1,.1,.1,.1,0,0,1,-.1,.1,.1,0,0,1,.1,-.1,-.1,0,0,-1,-.1,-.1,-.1,0,0,-1,-.1,.1,-.1,0,0,-1,.1,.1,-.1,0,0,-1,-.1,.1,-.1,0,1,0,.1,.1,-.1,0,1,0,.1,.1,.1,0,1,0,-.1,.1,.1,0,1,0,-.1,-.1,.1,0,-1,0,.1,-.1,.1,0,-1,0,.1,-.1,-.1,0,-1,0,-.1,-.1,-.1,0,-1,0,.1,-.1,-.1,1,0,0,.1,-.1,.1,1,0,0,.1,.1,.1,1,0,0,.1,.1,-.1,1,0,0,-.1,-.1,.1,-1,0,0,-.1,-.1,-.1,-1,0,0,-.1,.1,-.1,-1,0,0,-.1,.1,.1,-1,0,0]),i.unmap(),{index:n,vertex:i}})(n),this.instances=t,this.pipeline=n.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x3"}]}],entryPoint:"main",module:n.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) direction : vec3<f32>,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst worldUp : vec3<f32> = vec3<f32>(0, 1, 0);\n\nfn getRotation(direction : vec3<f32>) -> mat3x3<f32> {\n  let xaxis : vec3<f32> = normalize(cross(worldUp, direction));\n  let yaxis : vec3<f32> = normalize(cross(direction, xaxis));\n  return mat3x3<f32>(xaxis, yaxis, direction);\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(projectile : VertexInput) -> VertexOutput {\n  let rotation : mat3x3<f32> = getRotation(projectile.direction);\n  let position : vec3<f32> = rotation * projectile.position + projectile.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * projectile.normal);\n  out.depth = -mvPosition.z;\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) depth : f32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@group(0) @binding(1) var<uniform> sunlight : vec3<f32>;\n\n@fragment\nfn main(projectile : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = vec4<f32>(sunlight * 1.2, 1);\n  output.data = vec4<f32>(normalize(projectile.normal), projectile.depth);\n  return output;\n}\n"}),targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:{buffer:o.buffer}}]})}render(e){const{bindings:n,instances:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,n),e.setIndexBuffer(i.index,"uint16"),e.setVertexBuffer(0,i.vertex),e.setVertexBuffer(1,t,20),e.drawIndexedIndirect(t,0)}}class C{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const n=e.createBuffer({mappedAtCreation:!0,size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}],entryPoint:"main",module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"})},fragment:{entryPoint:"main",module:e.createShaderModule({code:"\n@group(0) @binding(0) var colorTexture : texture_2d<f32>;\n@group(0) @binding(1) var dataTexture : texture_2d<f32>;\n\nconst edgeColor : vec3<f32> = vec3<f32>(0, 0, 0);\nconst edgeIntensity : f32 = 0.4;\nconst depthScale : f32 = 0.4;\nconst normalScale : f32 = 0.4;\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edge(pixel : vec2<i32>) -> f32 {\n  let pixelCenter : vec4<f32> = textureLoad(dataTexture, pixel, 0);\n  let pixelLeft : vec4<f32> = textureLoad(dataTexture, pixel - offset.xz, 0);\n  let pixelRight : vec4<f32> = textureLoad(dataTexture, pixel + offset.xz, 0);\n  let pixelUp : vec4<f32> = textureLoad(dataTexture, pixel + offset.zy, 0);\n  let pixelDown : vec4<f32> = textureLoad(dataTexture, pixel - offset.zy, 0);\n  let edge : vec4<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return clamp(max((edge.x + edge.y + edge.z) * normalScale, edge.w * depthScale), 0, 1);\n}\n\nfn linearTosRGB(linear : vec3<f32>) -> vec3<f32> {\n  if (all(linear <= vec3<f32>(0.0031308))) {\n    return linear * 12.92;\n  }\n  return (pow(abs(linear), vec3<f32>(1.0/2.4)) * 1.055) - vec3<f32>(0.055);\n}\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  let pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, edgeColor, edge(pixel) * edgeIntensity);\n  return vec4<f32>(linearTosRGB(color), 1);\n}\n"}),targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures([e,n]){const{device:t,pipeline:i}=this;this.bindings=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:e.resolveTarget},{binding:1,resource:n.resolveTarget}]})}render(e,n){const{bindings:t,descriptor:i,geometry:o,pipeline:r}=this;i.colorAttachments[0].view=n;const a=e.beginRenderPass(i);a.setPipeline(r),a.setBindGroup(0,t),a.setVertexBuffer(0,o),a.draw(6,1,0,0),a.end()}}class A{constructor({adapter:e,camera:n,device:t,samples:i=4}){this.camera=n,this.device=t,this.samples=i;const o=navigator.gpu.getPreferredCanvasFormat(e);this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:o}),this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.postprocessing=new C({device:t,format:o}),this.scene=[],this.sunlight={buffer:t.createBuffer({size:3*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:new Float32Array(3)},this.textures=new Map}render(e){const{context:n,descriptor:t,postprocessing:i,scene:o}=this,r=e.beginRenderPass(t);o.forEach((e=>e.render(r))),r.end(),i.render(e,n.getCurrentTexture().createView())}setBackground(e,n,t){const{descriptor:{colorAttachments:[{clearValue:i}]}}=this;i.r=e,i.g=n,i.b=t}setSize(e,n){const{camera:t,canvas:i,descriptor:o,postprocessing:r}=this,a=window.devicePixelRatio||1,s=[Math.floor(e*a),Math.floor(n*a)];i.width=s[0],i.height=s[1],i.style.width=`${e}px`,i.style.height=`${n}px`,t.aspect=e/n,t.updateProjection(),this.updateTexture(o.colorAttachments[0],"rgba16float","color",s),this.updateTexture(o.colorAttachments[1],"rgba16float","data",s),this.updateTexture(o.depthStencilAttachment,"depth24plus","depth",s,!1),r.bindTextures(o.colorAttachments)}setSunlight(e,n,t){const{device:i,sunlight:o}=this;o.data[0]=e,o.data[1]=n,o.data[2]=t,i.queue.writeBuffer(o.buffer,0,o.data)}updateTexture(e,n,t,i,o=!0){const{device:r,samples:a,textures:s}=this,u=s.get(t);u&&u.forEach((e=>e.destroy())),s.set(t,[a,...o?[1]:[]].map((t=>{const o=r.createTexture({format:n,sampleCount:t,size:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|(1===t?GPUTextureUsage.TEXTURE_BINDING:0)});return 1===t?e.resolveTarget=o.createView():e.view=o.createView(),o})))}}var R="sfx/ambient.ogg",q="sfx/shot.ogg";class I{constructor(){Promise.all([Promise.all([R,q].map((e=>fetch(e).then((e=>e.arrayBuffer()))))),new Promise((e=>{const n=()=>{window.removeEventListener("keydown",n),window.removeEventListener("mousedown",n),e()};window.addEventListener("keydown",n,!1),window.addEventListener("mousedown",n,!1)}))]).then((([e])=>(this.context=new window.AudioContext,Promise.all(e.map((e=>this.context.decodeAudioData(e))))))).then((([e,n])=>{const{context:t}=this;this.output=t.createGain(),this.output.connect(t.destination),document.addEventListener("visibilitychange",(()=>{this.output.gain.value="visible"===document.visibilityState?1:0}),!1);{const n=t.createBufferSource();n.buffer=e,n.loop=!0,n.start(0);const i=t.createGain();i.gain.value=.8,n.connect(i),i.connect(this.output)}this.sfx=t.createGain(),this.sfx.gain.value=.2,this.sfx.connect(this.output),this.buffers={shot:n}}))}play(e){const{buffers:n,context:t,sfx:i}=this;if(!n||!n[e])return;const o=n[e],r=t.createBufferSource();r.buffer=o,r.detune.value=1e3*(Math.random()-.25),r.connect(i),r.start(0)}}var N="\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const V=({count:e,width:n,height:t,generator:i})=>`\n${N}\n\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${i}\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  let id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  let tex : i32 = id / atlas.stride;\n  let index : i32 = id - tex * atlas.stride;\n  let y : i32 = index / atlas.width;\n  let pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class F{constructor({device:e,count:n=6,width:t=16,height:i=16}){this.device=e,this.count=n,this.width=t,this.height=i,this.texture=e.createTexture({dimension:"2d",format:"rgba8unorm-srgb",size:[t,i,n],usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING})}compute(e="\nconst stone : vec3<f32> = vec3<f32>(0.6, 0.6, 0.8);\nconst dirt : vec4<f32> = vec4<f32>(1, 1, 1, 1);\nconst grass : vec4<f32> = vec4<f32>(0.6, 1, 0.6, 1);\nconst trunk : vec3<f32> = vec3<f32>(1, 0.6, 0.6);\nconst leaves : vec3<f32> = vec3<f32>(0.6, 1, 0.6);\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  switch texture {\n    default {\n      let n = (max(noise3(vec3<f32>(vec2<f32>(pixel) * vec2<f32>(0.75, 1), 0)) - 0.5, 0) - 0.5) * 0.1;\n      return vec4<f32>(stone + n, 1);\n    }\n    case 1 {\n      return dirt;\n    }\n    case 2 {\n      let n = (max(noise3(vec3<f32>(vec2<f32>(pixel), 0)) - 0.5, 0) - 0.5) * 0.1;\n      return vec4<f32>(grass.xyz + n, 1);\n    }\n    case 3 {\n      if (pixel.y > 4 - i32(4 * noise3(vec3<f32>(vec2<f32>(pixel), 0)))) {\n        return dirt;\n      }\n      return grass;\n    }\n    case 4 {\n      let n = (max(noise3(vec3<f32>(vec2<f32>(pixel) * vec2<f32>(1, 0.75), 0)) - 0.5, 0) - 0.5) * 0.1;\n      return vec4<f32>(trunk + n, 1);\n    }\n    case 5 {\n      let n = (max(noise3(vec3<f32>(vec2<f32>(pixel) * vec2<f32>(0.75, 1), 0)) - 0.5, 0) - 0.5) * 0.2;\n      return vec4<f32>(leaves + n, 1);\n    }\n  }\n}\n"){const{device:n,count:t,width:i,height:o,texture:r}=this,a=[i,o,t],s=n.createTexture({dimension:"2d",format:"rgba8unorm",size:a,usage:GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING}),u=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:V({count:t,width:i,height:o,generator:e})})}}),c=n.createCommandEncoder(),d=c.beginComputePass();d.setPipeline(u),d.setBindGroup(0,n.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:s.createView()}]})),d.dispatchWorkgroups(Math.ceil(t*i*o/256)),d.end(),c.copyTextureToTexture({texture:s},{texture:r},a),n.queue.submit([c.finish()]),s.destroy()}setupDragAndDrop(){window.addEventListener("dragenter",(e=>e.preventDefault()),!1),window.addEventListener("dragover",(e=>e.preventDefault()),!1),window.addEventListener("drop",(e=>{e.preventDefault();const[n]=e.dataTransfer.files;if(!n||0!==n.type.indexOf("image/"))return;const t=new Image;t.addEventListener("load",(()=>{const{device:e,count:n,width:i,height:o,texture:r}=this,a=document.createElement("canvas"),s=a.getContext("2d");a.width=i,a.height=o*n,s.drawImage(t,0,0);const u=s.getImageData(0,0,a.width,a.height);e.queue.writeTexture({texture:r},u.data.buffer,{bytesPerRow:4*i,rowsPerImage:o},[i,o,n])}),!1),t.src=URL.createObjectURL(n)}),!1)}}class Y{constructor({camera:e,chunks:n,device:t,samples:i,sunlight:o}){this.atlas=new F({device:t}),this.chunks=n,this.device=t,this.geometry=(e=>{const n=e.createBuffer({mappedAtCreation:!0,size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n})(t),this.pipeline=t.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:4,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:5,offset:5*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:t.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) light : f32,\n  @location(4) face : f32,\n  @location(5) texture : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\nconst PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  let c : f32 = cos(rad);\n  let s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  let c : f32 = cos(rad);\n  let s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\nfn getRotation(face : i32) -> mat3x3<f32> {\n  switch face {\n    default {\n      return mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      return rotateX(PI * -0.5);\n    }\n    case 2 {\n      return rotateX(PI * 0.5);\n    }\n    case 3 {\n      return rotateY(PI * -0.5);\n    }\n    case 4 {\n      return rotateY(PI * 0.5);\n    }\n    case 5 {\n      return rotateY(PI);\n    }\n  }\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<uniform> sunlight : vec3<f32>;\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  let rotation : mat3x3<f32> = getRotation(i32(voxel.face));\n  let position : vec3<f32> = rotation * voxel.position + voxel.origin;\n  let mvPosition : vec4<f32> = camera.view * vec4<f32>(position, 1);\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.normal = normalize(rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.depth = -mvPosition.z;\n  out.light = sunlight * pow(voxel.light, 16);\n  out.texture = i32(voxel.texture);\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:t.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) normal : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) depth : f32,\n  @location(3) @interpolate(flat) light : vec3<f32>,\n  @location(4) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) data : vec4<f32>,\n}\n\n@group(0) @binding(2) var atlas : texture_2d_array<f32>;\n@group(0) @binding(3) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.color *= vec4<f32>(face.light, 1);\n  output.data = vec4<f32>(normalize(face.normal), face.depth);\n  return output;\n}\n"}),targets:[{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:i}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:{buffer:o.buffer}},{binding:2,resource:this.atlas.texture.createView()},{binding:3,resource:t.createSampler()}]})}render(e){const{bindings:n,chunks:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,n),e.setVertexBuffer(0,i),t.forEach((({faces:n})=>{e.setVertexBuffer(1,n,16),e.drawIndirect(n,0)}))}}class O{constructor({chunkSize:e,device:n,position:t}){this.bindings={},this.position=g(t),this.bounds=n.createBuffer({mappedAtCreation:!0,size:6*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.bounds.getMappedRange()).set([e.x,e.y,e.z]),this.bounds.unmap(),this.data=n.createBuffer({size:(e.x*e.y*e.z*2+2*(1+e.x*e.z*4)+1+1)*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),this.faces=n.createBuffer({size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(e.x*e.y*e.z*.5)*6*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),this.offset=n.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.offset.getMappedRange()).set([t[0]*e.x,0,t[1]*e.z]),this.offset.unmap()}}O.compute=({atomicBounds:e,atomicInstanceCount:n,atomicQueueCount:t,atomicLight:i,atomicValue:o,chunkSize:r})=>`\n  const chunkSize : vec3<i32> = vec3<i32>(${r.x}, ${r.y}, ${r.z});\n  const maxLight : u32 = 255;\n\n  struct Bounds {\n    min : array<${e?"atomic<u32>":"u32"}, 3>,\n    max : array<${e?"atomic<u32>":"u32"}, 3>,\n  }\n\n  struct Faces {\n    vertexCount : u32,\n    instanceCount : ${n?"atomic<u32>":"u32"},\n    firstVertex : u32,\n    firstInstance : u32,\n    data : array<f32>,\n  }\n\n  struct Queue {\n    count : ${t?"atomic<u32>":"u32"},\n    data : array<u32, ${r.x*r.z*4}>,\n  }\n\n  struct Voxel {\n    value : ${o?"atomic<u32>":"u32"},\n    light : ${i?"atomic<u32>":"u32"},\n  }\n\n  struct Chunk {\n    voxels : array<Voxel, ${r.x*r.y*r.z}>,\n    queues : array<Queue, 2>,\n    queue : u32,\n    remesh : u32,\n  }\n\n  fn getVoxel(pos : vec3<i32>) -> u32 {\n    return u32(pos.z * chunkSize.x * chunkSize.y + pos.y * chunkSize.x + pos.x);\n  }\n\n  fn getPos(voxel : u32) -> vec3<i32> {\n    let o : i32 = i32(voxel) % (chunkSize.x * chunkSize.y);\n    return vec3<i32>(\n      o % chunkSize.x,\n      o / chunkSize.x,\n      i32(voxel) / (chunkSize.x * chunkSize.y),\n    );\n  }\n`;class ${constructor({device:e,camera:n}){this.buffer=e.createBuffer({size:24*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),this.pipeline=e.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:e.createShaderModule({code:"\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<storage, read_write> frustum : array<vec4<f32>, 6>;\n\nfn update(index : i32, plane : vec4<f32>) {\n  frustum[index] = plane * (1 / length(plane.xyz));\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  let m : mat4x4<f32> = camera.projection * camera.view;\n  update(0, vec4<f32>(m[0].w - m[0].x, m[1].w - m[1].x, m[2].w - m[2].x, m[3].w - m[3].x));\n  update(1, vec4<f32>(m[0].w + m[0].x, m[1].w + m[1].x, m[2].w + m[2].x, m[3].w + m[3].x));\n  update(2, vec4<f32>(m[0].w + m[0].y, m[1].w + m[1].y, m[2].w + m[2].y, m[3].w + m[3].y));\n  update(3, vec4<f32>(m[0].w - m[0].y, m[1].w - m[1].y, m[2].w - m[2].y, m[3].w - m[3].y));\n  update(4, vec4<f32>(m[0].w - m[0].z, m[1].w - m[1].z, m[2].w - m[2].z, m[3].w - m[3].z));\n  update(5, vec4<f32>(m[0].w + m[0].z, m[1].w + m[1].z, m[2].w + m[2].z, m[3].w + m[3].z));\n}\n"})}}),this.bindings=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:this.buffer}}]})}compute(e){const{bindings:n,pipeline:t}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(1)}}const D=({chunkSize:e})=>`\n${O.compute({atomicQueueCount:!0,atomicLight:!0,chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n\nfn flood(pos : vec3<i32>, level : u32) {\n  // I really tried to make this with pointers\n  // and a single logic block but I couldn't manage to\n  // pass a ptr<storage, Chunk, read_write> to a function\n  if (pos.x == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (chunk_west.voxels[voxel].value != 0) {\n      chunk_west.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_west.voxels[voxel].light, level) < level) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&chunk_west.queues[chunk_west.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    let voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (chunk_east.voxels[voxel].value != 0) {\n      chunk_east.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_east.voxels[voxel].light, level) < level) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&chunk_east.queues[chunk_east.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (chunk_south.voxels[voxel].value != 0) {\n      chunk_south.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_south.voxels[voxel].light, level) < level) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&chunk_south.queues[chunk_south.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (chunk_north.voxels[voxel].value != 0) {\n      chunk_north.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_north.voxels[voxel].light, level) < level) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&chunk_north.queues[chunk_north.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  let voxel : u32 = getVoxel(pos);\n  if (chunk.voxels[voxel].value != 0) {\n    return;\n  }\n  if (atomicMax(&chunk.voxels[voxel].light, level) < level) {\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= uniforms.count) {\n    return;\n  }\n  let voxel : u32 = chunk.queues[uniforms.queue].data[id.x];\n  let light : u32 = atomicLoad(&chunk.voxels[voxel].light);\n  let pos : vec3<i32> = getPos(voxel);\n  for (var n : i32 = 0; n < 6; n++) {\n    let npos = pos + neighbors[n];\n    if (npos.y == -1 || npos.y == chunkSize.y) {\n      continue;\n    }\n    var level : u32 = light;\n    if (n != 0 || level < maxLight) {\n      level -= 1;\n    }\n    flood(npos, level);\n  }\n}\n`;class j{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:D({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups=i}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.lightingCompute||(n.bindings.lightingCompute=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingCompute),e.dispatchWorkgroupsIndirect(r,0)}}const W=({chunkSize:e})=>`\n${O.compute({chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> uniforms : Uniforms;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n\n@compute @workgroup_size(1)\nfn main() {\n  let count : u32 = chunk.queues[chunk.queue].count;\n  if (count == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n\n  uniforms.count = count;\n  uniforms.queue = chunk.queue;\n\n  workgroups[0] = u32(ceil(f32(count) / 256));\n  workgroups[1] = 1;\n  workgroups[2] = 1;\n\n  let next : u32 = (chunk.queue + 1) % 2;\n  chunk.queue = next;\n  chunk.queues[next].count = 0;\n\n  chunk.remesh = 1;\n}\n`;class X{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:W({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.lightingSetup||(n.bindings.lightingSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingSetup),e.dispatchWorkgroups(1)}}class Q{constructor({chunkSize:e,device:n}){const t=n.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.propagate=new j({chunkSize:e,device:n,uniforms:t,workgroups:i}),this.setup=new X({chunkSize:e,device:n,uniforms:t,workgroups:i})}compute(e,n){const{propagate:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const H=({chunkSize:e})=>`\n${O.compute({atomicInstanceCount:!0,chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read> chunk : Chunk;\n@group(0) @binding(1) var<storage, read> chunk_east : Chunk;\n@group(0) @binding(2) var<storage, read> chunk_west : Chunk;\n@group(0) @binding(3) var<storage, read> chunk_north : Chunk;\n@group(0) @binding(4) var<storage, read> chunk_south : Chunk;\n@group(0) @binding(5) var<storage, read_write> faces : Faces;\n@group(0) @binding(6) var<uniform> position : vec3<i32>;\n\nstruct Normals {\n  f : vec3<i32>,\n  u : vec3<i32>,\n  v : vec3<i32>,\n}\n\nconst faceNormals = array<Normals, 6>(\n  Normals(vec3<i32>(0, 0, 1), vec3<i32>(0, 1, 0), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, 1, 0), vec3<i32>(0, 0, -1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, -1, 0), vec3<i32>(0, 0, 1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(-1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(0, 0, -1), vec3<i32>(0, 1, 0), vec3<i32>(-1, 0, 0)),\n);\n\nconst lightSamples = array<vec2<i32>, 5>(\n  vec2<i32>(0, 0),\n  vec2<i32>(-1, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, -1),\n  vec2<i32>(0, 1),\n);\n\nfn getNeighbor(pos : vec3<i32>) -> Voxel {\n  if (\n    pos.y < 0\n    || (pos.x < 0 && pos.z < 0)\n    || (pos.x >= chunkSize.x && pos.z < 0)\n    || (pos.x < 0 && pos.z >= chunkSize.z)\n    || (pos.x >= chunkSize.x && pos.z >= chunkSize.z)\n  ) {\n    return Voxel(1, 0);\n  }\n  if (pos.y >= chunkSize.y) {\n    return Voxel(0, maxLight);\n  }\n  if (pos.x < 0) {\n    return chunk_west.voxels[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.voxels[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.z < 0) {\n    return chunk_south.voxels[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))];\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.voxels[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))];\n  }\n  return chunk.voxels[getVoxel(pos)];\n}\n\nfn getLight(pos : vec3<i32>, u : vec3<i32>, v : vec3<i32>) -> f32 {\n  var level : f32;\n  var count : i32;\n  for (var i : i32 = 0; i < 5; i++) {\n    let uv = lightSamples[i];\n    let npos : vec3<i32> = pos + u * uv.x + v * uv.y;\n    let neighbor : Voxel = getNeighbor(npos);\n    if (neighbor.value == 0 && neighbor.light != 0) {\n      level += f32(neighbor.light);\n      count++;\n    }\n  }\n  return level / f32(max(count, 1)) / f32(maxLight);\n}\n\nfn getTexture(face : i32, value : u32) -> i32 {\n  switch value {\n    default {\n      return i32(value) - 1;\n    }\n    case 3 {\n      if (face == 1) {\n        return 2;\n      }\n      if (face == 2) {\n        return 1;\n      }\n      return 3;\n    }\n    case 4, 5 {\n      return i32(value);\n    }\n  }\n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32, light : f32) {\n  if (light == 0) {\n    return;\n  }\n  let offset : u32 = atomicAdd(&faces.instanceCount, 1) * 6;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = light;\n  faces.data[offset + 4] = f32(face);\n  faces.data[offset + 5] = f32(texture);\n}\n\n@compute @workgroup_size(64, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (any(pos >= chunkSize)) {\n    return;\n  }\n  let value : u32 = chunk.voxels[getVoxel(pos)].value;\n  if (value != 0) {\n    for (var face : i32 = 0; face < 6; face++) {\n      let npos : vec3<i32> = pos + faceNormals[face].f;\n      if (getNeighbor(npos).value == 0) {\n        pushFace(\n          position + pos,\n          face,\n          getTexture(face, value),\n          getLight(npos, faceNormals[face].u, faceNormals[face].v)\n        );\n      }\n    }\n  }\n}\n`;class K{constructor({chunkSize:e,device:n,workgroups:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:H({chunkSize:e})}),entryPoint:"main"}}),this.workgroups=t}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.mesherCompute||(n.bindings.mesherCompute=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[n,...n.neighbors,{data:n.faces},{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(i),e.setBindGroup(0,n.bindings.mesherCompute),e.dispatchWorkgroupsIndirect(o,0)}}const J=({chunkSize:e})=>`\n${O.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<uniform> frustum : array<vec4<f32>, 6>;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read> bounds : Bounds;\n@group(1) @binding(1) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(2) var<storage, read_write> faces : Faces;\n@group(1) @binding(3) var<uniform> position : vec3<i32>;\n\nfn isInFrustum() -> bool {\n  let origin : vec3<f32> = vec3<f32>(position);\n  for (var i : i32 = 0; i < 6; i++) {\n    let plane : vec4<f32> = frustum[i];\n    var corner : vec3<f32>;\n    for (var j : i32 = 0; j < 3; j++) {\n      if (plane[j] > 0) {\n        corner[j] = f32(bounds.max[j]);\n      } else {\n        corner[j] = f32(bounds.min[j]);\n      }\n    }\n    if ((dot(plane.xyz, origin + corner) + plane.w) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  if (isInFrustum()) {\n    faces.vertexCount = 6;\n  } else {\n    faces.vertexCount = 0;\n  }\n  if (chunk.remesh == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n  chunk.remesh = 0;\n  faces.instanceCount = 0;\n  workgroups[0] = u32(ceil(f32(chunkSize.x) / 64));\n  workgroups[1] = u32(ceil(f32(chunkSize.y) / 4));\n  workgroups[2] = u32(chunkSize.z);\n}\n`;class Z{constructor({chunkSize:e,device:n,frustum:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:J({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.mesherSetup||(n.bindings.mesherSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.bounds}},{binding:1,resource:{buffer:n.data}},{binding:2,resource:{buffer:n.faces}},{binding:3,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.mesherSetup),e.dispatchWorkgroups(1)}}class ee{constructor({chunkSize:e,device:n,frustum:t}){const i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.mesh=new K({chunkSize:e,device:n,workgroups:i}),this.setup=new Z({chunkSize:e,device:n,frustum:t,workgroups:i})}compute(e,n){const{mesh:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const ne=({chunkSize:e,count:n})=>`\n${O.compute({atomicQueueCount:!0,atomicValue:!0,chunkSize:e})}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  distance: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> state : array<Projectile, ${n}>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n@group(1) @binding(5) var<uniform> position : vec3<i32>;\n\nfn flood(pos : vec3<i32>) {\n  if (pos.y == -1 || pos.y == chunkSize.y) {\n    return;\n  }\n  if (pos.x == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (atomicLoad(&chunk_west.voxels[voxel].value) == 0 && chunk_west.voxels[voxel].light != 0) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&chunk_west.queues[chunk_west.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    let voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (atomicLoad(&chunk_east.voxels[voxel].value) == 0 && chunk_east.voxels[voxel].light != 0) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&chunk_east.queues[chunk_east.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (atomicLoad(&chunk_south.voxels[voxel].value) == 0 && chunk_south.voxels[voxel].light != 0) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&chunk_south.queues[chunk_south.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    let voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (atomicLoad(&chunk_north.voxels[voxel].value) == 0 && chunk_north.voxels[voxel].light != 0) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&chunk_north.queues[chunk_north.queue].count, 1)] = voxel;\n    }\n    return;\n  }\n  let voxel : u32 = getVoxel(pos);\n  if (atomicLoad(&chunk.voxels[voxel].value) == 0 && chunk.voxels[voxel].light != 0) {\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(${Math.min(n,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (\n    id.x >= ${n}\n    || state[id.x].state == 0\n  ) {\n    return;\n  }\n  let pos : vec3<i32> = vec3<i32>(floor(state[id.x].position)) - position;\n  for (var z : i32 = -1; z <= 1; z++) {\n    for (var y : i32 = -1; y <= 1; y++) {\n      for (var x : i32 = -1; x <= 1; x++) {\n        let npos : vec3<i32> = pos + vec3<i32>(x, y, z);\n        if (\n          any(npos < vec3<i32>(0))\n          || any(npos >= chunkSize)\n        ) {\n          continue;\n        }\n        if (npos.y == 0) {\n          state[id.x].state = 0;\n          continue;\n        }\n        let voxel : u32 = getVoxel(npos);\n        if (atomicMin(&chunk.voxels[voxel].value, 0) != 0) {\n          state[id.x].state = 2;\n          for (var n : i32 = 0; n < 6; n++) {\n            flood(npos + neighbors[n]);\n          }\n        }\n      }\n    }\n  }\n}\n`;class te{constructor({chunkSize:e,count:n,device:t,state:i}){this.device=t,this.pipeline=t.createComputePipeline({layout:"auto",compute:{module:t.createShaderModule({code:ne({chunkSize:e,count:n})}),entryPoint:"main"}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:i}}]}),this.workgroups=Math.ceil(n/256)}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.projectiles||(n.bindings.projectiles=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors,{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.projectiles),e.dispatchWorkgroups(r)}}const ie=({count:e})=>`\nstruct Input {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  enabled: atomic<u32>,\n}\n\nstruct Instances {\n  indexCount : u32,\n  instanceCount : atomic<u32>,\n  firstIndex : u32,\n  baseVertex : u32,\n  firstInstance : u32,\n  data : array<f32>,\n}\n\nstruct Projectile {\n  position: vec3<f32>,\n  direction: vec3<f32>,\n  distance: u32,\n  state: u32,\n}\n\n@group(0) @binding(0) var<uniform> delta : f32;\n@group(0) @binding(1) var<storage, read_write> input : Input;\n@group(0) @binding(2) var<storage, read_write> instances : Instances;\n@group(0) @binding(3) var<storage, read_write> state : array<Projectile, ${e}>;\n\nfn pushInstance(position : vec3<f32>, direction : vec3<f32>) {\n  let offset : u32 = atomicAdd(&instances.instanceCount, 1) * 6;\n  instances.data[offset] = position.x;\n  instances.data[offset + 1] = position.y;\n  instances.data[offset + 2] = position.z;\n  instances.data[offset + 3] = direction.x;\n  instances.data[offset + 4] = direction.y;\n  instances.data[offset + 5] = direction.z;\n}\n\n@compute @workgroup_size(${Math.min(e,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= ${e}) {\n    return;\n  }\n  if (state[id.x].state == 1) {\n    state[id.x].distance++;\n    if (state[id.x].distance > 256) {\n      state[id.x].state = 0;\n      return;\n    }\n    let direction : vec3<f32> = state[id.x].direction;\n    state[id.x].position += direction * delta * 60;\n    pushInstance(state[id.x].position, direction);\n    return;\n  }\n  if (state[id.x].state == 2) {\n    // @incomplete: Spawn explosion at state[id.x].position\n    state[id.x].state = 0;\n  }\n  if (atomicMin(&input.enabled, 0) != 0) {\n    state[id.x].position = input.position; \n    state[id.x].direction = input.direction; \n    state[id.x].distance = 0;\n    state[id.x].state = 1;\n  }\n}\n`;class oe{constructor({count:e,delta:n,device:t,input:i,instances:o,state:r}){this.pipeline=t.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:t.createShaderModule({code:ie({count:e})})}}),this.bindings=t.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:i.buffer}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:r}}]}),this.workgroups=Math.ceil(e/256)}compute(e){const{bindings:n,pipeline:t,workgroups:i}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(i)}}class re{constructor({count:e=32,chunkSize:n,device:t}){this.device=t;{const e=new Float32Array(1);this.delta={buffer:t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),data:e}}{const e=new Float32Array(8);this.input={buffer:t.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),data:e.buffer,position:e.subarray(0,3),direction:e.subarray(4,7),enabled:new Uint32Array(e.buffer,28,1)}}this.instances=t.createBuffer({mappedAtCreation:!0,size:5*Uint32Array.BYTES_PER_ELEMENT+6*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),new Uint32Array(this.instances.getMappedRange(0,Uint32Array.BYTES_PER_ELEMENT))[0]=36,this.instances.unmap(),this.state=t.createBuffer({size:12*e*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),this.passes={compute:new te({chunkSize:n,count:e,device:t,state:this.state}),step:new oe({count:e,delta:this.delta,device:t,input:this.input,instances:this.instances,state:this.state})}}compute(e,n){const{passes:{compute:t}}=this;t.compute(e,n)}setup(e,n){const{delta:{buffer:t,data:i},device:o,instances:r}=this;i[0]=n,o.queue.writeBuffer(t,0,i),e.clearBuffer(r,4,4)}shoot(e,n){const{device:t,input:i}=this;u(i.position,n),u(i.direction,e),i.enabled[0]=1,t.queue.writeBuffer(i.buffer,0,i.data)}step(e){const{passes:{step:n}}=this;n.compute(e)}}const ae=({chunkSize:e})=>`\n${O.compute({chunkSize:e})}\n\nstruct Query {\n  input : vec4<i32>,\n  operation : i32,\n  output : i32,\n}\n\n@group(0) @binding(0) var<storage, read_write> query : Query;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n\nfn getGround() -> i32 {\n  var pos : vec3<i32> = query.input.xyz;\n  let height : i32 = query.input.w;\n  if (\n    chunk.voxels[getVoxel(pos)].value != 0\n  ) {\n    return -1;\n  }\n  pos.y--;\n  for (; pos.y >= 0; pos.y--) {\n    if (chunk.voxels[getVoxel(pos)].value == 0) {\n      continue;\n    }\n    for (var h : i32 = 1; h <= height; h++) {\n      let npos : vec3<i32> = pos + vec3<i32>(0, h, 0);\n      if (npos.y >= chunkSize.y) {\n        break;\n      }\n      if (chunk.voxels[getVoxel(npos)].value != 0) {\n        return -1;\n      }\n    }\n    return pos.y + 1;\n  }\n  return 0;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  switch query.operation {\n    default {}\n    case 1 {\n      query.output = getGround();\n    }\n  }\n}\n`;class se{constructor({chunkSize:e,device:n}){this.device=n,this.outputBuffers=[],this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:ae({chunkSize:e})})}}),this.query={buffer:n.createBuffer({size:6*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE}),input:new Int32Array(5)},this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.query.buffer}}]})}compute(e){const{bindings:n,device:t,outputBuffers:i,pipeline:o,query:r}=this;e.bindings.query||(e.bindings.query=t.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:e.data}}]}));const a=i.pop()||t.createBuffer({size:Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),s=t.createCommandEncoder(),u=s.beginComputePass();return u.setPipeline(o),u.setBindGroup(0,n),u.setBindGroup(1,e.bindings.query),u.dispatchWorkgroups(1),u.end(),s.copyBufferToBuffer(r.buffer,20,a,0,4),t.queue.submit([s.finish()]),a.mapAsync(GPUMapMode.READ).then((()=>{const e=new Int32Array(a.getMappedRange())[0];return a.unmap(),i.push(a),e}))}getGround(e,n,t){const{device:i,query:o}=this;return o.input[0]=n[0],o.input[1]=n[1],o.input[2]=n[2],o.input[3]=t,o.input[4]=se.operations.ground,i.queue.writeBuffer(o.buffer,0,o.input),this.compute(e)}}se.operations={ground:1};const ue=({chunkSize:e,maxTrees:n})=>`\n${O.compute({atomicBounds:!0,chunkSize:e})}\n\n${N}\n\nstruct Trees {\n  count : u32,\n  data : array<u32, ${n}>,\n}\n\n@group(0) @binding(0) var<storage, read_write> trees : Trees;\n@group(1) @binding(0) var<storage, read_write> bounds : Bounds;\n@group(1) @binding(1) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(2) var<uniform> position : vec3<i32>;\n\nfn grow(pos : vec3<i32>, value : u32) -> bool {\n  if (pos.y >= chunkSize.y - 1) {\n    return false;\n  }\n  let voxel : u32 = getVoxel(pos);\n  let v : u32 = chunk.voxels[voxel].value;\n  if (v != 0 && v != 4 && v != 5) {\n    return false;\n  }\n  chunk.voxels[voxel].value = value;\n  atomicMin(&bounds.min[0], u32(pos.x));\n  atomicMin(&bounds.min[1], u32(pos.y));\n  atomicMin(&bounds.min[2], u32(pos.z));\n  atomicMax(&bounds.max[0], u32(pos.x) + 1);\n  atomicMax(&bounds.max[1], u32(pos.y) + 1);\n  atomicMax(&bounds.max[2], u32(pos.z) + 1);\n  return true;\n}\n\n@compute @workgroup_size(${Math.min(n,256)})\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  if (id.x >= trees.count) {\n    return;\n  }\n  let pos : vec3<i32> = getPos(trees.data[id.x]) + vec3<i32>(0, -1, 0);\n  let height : i32 = 8 + i32(abs(noise3(vec3<f32>(position + pos) * 0.1)) * 8);\n  for (var i : i32 = 0; i < height; i++) {\n    if (!grow(pos + vec3<i32>(0, i, 0), 4) && i > 1) {\n      return;\n    }\n  }\n  let radius : f32 = 3 + abs(noise3(vec3<f32>(position + pos.yzx) * 0.05)) * 2;\n  let iradius : i32 = i32(ceil(radius + 0.5));\n  let offset : vec3<i32> = vec3<i32>(0, height, 0);\n  for (var z : i32 = -iradius; z <= iradius; z++) {\n    for (var y : i32 = -3; y <= iradius; y++) {\n      for (var x : i32 = -iradius; x <= iradius; x++) {\n        let npos : vec3<i32> = vec3<i32>(x, y, z);\n        if (length(vec3<f32>(npos)) < radius) {\n          grow(pos + offset + npos, 5);\n        }\n      }\n    }\n  }\n}\n`;class ce{constructor({chunkSize:e,device:n,trees:t}){const i=t.size/4-1;this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:ue({chunkSize:e,maxTrees:i})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups=Math.ceil(i/256)}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.grow||(n.bindings.grow=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.bounds}},{binding:1,resource:{buffer:n.data}},{binding:2,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.grow),e.dispatchWorkgroups(r)}}const de=({chunkSize:e,maxTrees:n})=>`\n${O.compute({chunkSize:e})}\n\n${N}\n\nstruct Trees {\n  count : atomic<u32>,\n  data : array<u32, ${n}>,\n}\n\n@group(0) @binding(0) var<storage, read_write> trees : Trees;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(64, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (any(pos >= chunkSize)) {\n    return;\n  }\n  let voxel = getVoxel(pos);\n  if (\n    chunk.voxels[voxel].value == 2\n    && chunk.voxels[getVoxel(pos + vec3<i32>(0, 1, 0))].value == 0\n  ) {\n    chunk.voxels[voxel].value = 3;\n    if (\n      all(pos > vec3<i32>(5, 4, 5))\n      && all(pos < (chunkSize - vec3<i32>(6, 20, 6)))\n      && simplexNoise3(vec3<f32>(position + pos)) > 0.9\n    ) {\n      let tree = atomicAdd(&trees.count, 1);\n      if (tree < ${n}) {\n        trees.data[tree] = voxel;\n      }\n    }\n  }\n}\n`;class pe{constructor({chunkSize:e,device:n,trees:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:de({chunkSize:e,maxTrees:t.size/4-1})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups={x:Math.ceil(e.x/64),y:Math.ceil(e.y/4),z:e.z}}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.populate||(n.bindings.populate=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.populate),e.dispatchWorkgroups(r.x,r.y,r.z)}}const le=({chunkSize:e})=>`\n${O.compute({atomicBounds:!0,atomicQueueCount:!0,chunkSize:e})}\n\n${N}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += simplexNoise3(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n@group(0) @binding(0) var<storage, read_write> trees : u32;\n@group(1) @binding(0) var<storage, read_write> bounds : Bounds;\n@group(1) @binding(1) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(2) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(64, 4)\nfn main(@builtin(global_invocation_id) id : vec3<u32>) {\n  let pos : vec3<i32> = vec3<i32>(id.xyz);\n  if (any(pos >= chunkSize)) {\n    return;\n  }\n\n  if (pos.y == chunkSize.y - 1) {\n    let voxel = getVoxel(pos);\n    chunk.voxels[voxel].light = maxLight;\n    chunk.queues[chunk.queue].data[atomicAdd(&chunk.queues[chunk.queue].count, 1)] = voxel;\n    if (pos.x == 0 && pos.z == 0) {\n      // This is a bit hacky but I don't want to add\n      // yet another pipeline just for this\n      trees = 0;\n    }\n    return;\n  }\n\n  let wpos = vec3<f32>(position + pos);\n  if (wpos.y == 0 || wpos.y <= abs(FBM(wpos * 0.015) + 0.3) * f32(chunkSize.y) * 1.2) {\n    var value : u32;\n    if (abs(FBM(wpos.yzx * vec3<f32>(0.06, 0.03, 0.03))) > 0.3) {\n      value = 1;\n    } else {\n      value = 2;\n    }\n    chunk.voxels[getVoxel(pos)].value = value;\n    atomicMin(&bounds.min[0], u32(pos.x));\n    atomicMin(&bounds.min[1], u32(pos.y));\n    atomicMin(&bounds.min[2], u32(pos.z));\n    atomicMax(&bounds.max[0], u32(pos.x) + 1);\n    atomicMax(&bounds.max[1], u32(pos.y) + 1);\n    atomicMax(&bounds.max[2], u32(pos.z) + 1);\n  }\n}\n`;class fe{constructor({chunkSize:e,device:n,trees:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:le({chunkSize:e})}),entryPoint:"main"}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups={x:Math.ceil(e.x/64),y:Math.ceil(e.y/4),z:e.z}}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.terrain||(n.bindings.terrain=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.bounds}},{binding:1,resource:{buffer:n.data}},{binding:2,resource:{buffer:n.offset}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.terrain),e.dispatchWorkgroups(r.x,r.y,r.z)}}class he{constructor({chunkSize:e,device:n}){this.trees=n.createBuffer({size:25*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.UNIFORM}),this.grow=new ce({chunkSize:e,device:n,trees:this.trees}),this.populate=new pe({chunkSize:e,device:n,trees:this.trees}),this.terrain=new fe({chunkSize:e,device:n,trees:this.trees})}compute(e,n){const{grow:t,populate:i,terrain:o}=this;o.compute(e,n),i.compute(e,n),t.compute(e,n)}}const ge=h(),ve=[v(1,0),v(-1,0),v(0,1),v(0,-1)],me=r();class xe{constructor({chunkSize:e={x:64,y:64,z:64},camera:n,device:t}){this.chunkSize=e,this.device=t,this.chunks={data:new Map,loaded:[]},this.frustum=new $({device:t,camera:n}),this.lighting=new Q({chunkSize:e,device:t}),this.mesher=new ee({chunkSize:e,device:t,frustum:this.frustum}),this.projectiles=new re({chunkSize:e,device:t}),this.query=new se({chunkSize:e,device:t}),this.worldgen=new he({chunkSize:e,device:t})}compute(e,n){const{chunks:t,frustum:i,lighting:o,mesher:r,projectiles:a,worldgen:s}=this;a.setup(e,n);const u=e.beginComputePass();a.step(u),t.loaded.forEach((e=>{e.hasGenerated||(e.hasGenerated=!0,s.compute(u,e)),e.neighbors||(e.neighbors=ve.map((n=>{const t=this.getChunk(b(ge,e.position,n));return t.hasGenerated||(t.hasGenerated=!0,s.compute(u,t)),t}))),a.compute(u,e)})),t.loaded.forEach((e=>o.compute(u,e))),i.compute(u),t.loaded.forEach((e=>r.compute(u,e))),u.end()}getChunk(e){const{chunks:n,chunkSize:t,device:i}=this,o=`${e[0]}:${e[1]}`;let r=n.data.get(o);return r||(r=new O({chunkSize:t,device:i,position:e}),n.data.set(o,r)),r}static getGrid(e){let n=xe.grids.get(e);if(!n){n=[];for(let t=-e;t<=e;t++)for(let i=-e;i<=e;i++){x(ge,i,t);const o=y(ge);o<=e-.5&&n.push({distance:o,position:g(ge)})}n.sort((({distance:e},{distance:n})=>e-n)),n=n.map((({position:e})=>e)),xe.grids.set(e,n)}return n}getGround(e,n=4){const{chunkSize:t,chunks:i,query:o}=this;x(ge,Math.floor(e[0]/t.x),Math.floor(e[2]/t.z));const r=`${ge[0]}:${ge[1]}`,a=i.data.get(r);return a&&a.hasGenerated?(u(me,e),me[0]-=ge[0]*t.x,me[1]=Math.min(me[1],t.y-1),me[2]-=ge[1]*t.z,o.getGround(a,me,n)):Promise.resolve(-1)}load(e,n,t){const{chunks:i}=this;for(let n=0,u=i.loaded.length;n<u;n++){const c=i.loaded[n];o=e,r=c.position,a=void 0,s=void 0,a=r[0]-o[0],s=r[1]-o[1],Math.hypot(a,s)>t-.5&&(c.isLoaded=!1,i.loaded.splice(n,1),n--,u--)}var o,r,a,s;xe.getGrid(n).forEach((n=>{const t=this.getChunk(b(ge,e,n));t.isLoaded||(t.isLoaded=!0,i.loaded.push(t))}))}}xe.grids=new Map;(async()=>{if(!navigator.gpu)throw new Error("WebGPU support");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGPU adapter");const n=await e.requestDevice(),t=n.createShaderModule({code:"const checkConstSupport : f32 = 1;"}),{messages:i}=await t.compilationInfo();if(i.find((({type:e})=>"error"===e)))throw new Error("WGSL const support");return{adapter:e,device:n}})().then((({adapter:n,device:t})=>{const i=new w({device:t}),o=new xe({camera:i,device:t}),a=new A({adapter:n,camera:i,device:t});document.getElementById("renderer").appendChild(a.canvas),a.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>a.setSize(window.innerWidth,window.innerHeight)),!1);const s=new Y({camera:i,chunks:o.chunks.loaded,device:t,samples:a.samples,sunlight:a.sunlight});s.atlas.compute(),s.atlas.setupDragAndDrop(),a.scene.push(s);const u=new U({instances:o.projectiles.instances,camera:i,device:t,samples:a.samples,sunlight:a.sunlight});a.scene.push(u),c(i.position,-.5*o.chunkSize.x+1.5,.2*o.chunkSize.y-1.5,1.5*o.chunkSize.z+1.5);const p=new T({camera:i,target:a.canvas,world:o}),l=new L(a),f=new I,g=h(),b=v(o.chunkSize.x,o.chunkSize.z),y=v(-1e3,-1e3),k=r();let z=performance.now()/1e3,E=z;document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(z=performance.now()/1e3)}),!1);const S=()=>{requestAnimationFrame(S);const n=performance.now()/1e3,r=Math.min(n-z,1);var s,u,c;z=n,p.update(r),l.update(r),function(e,n){e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1])}(g,(s=g,u=x(g,i.position[0],i.position[2]),c=b,s[0]=u[0]/c[0],s[1]=u[1]/c[1],s)),function(n,t){var i=n[0],o=n[1],r=t[0],a=t[1];return Math.abs(i-r)<=e*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(o-a)<=e*Math.max(1,Math.abs(o),Math.abs(a))}(y,g)||(m(y,g),o.load(g,4,5)),p.buttons.primary&&n-E>.05&&(E=n,o.projectiles.shoot(p.forward,d(k,i.position,p.forward)),f.play("shot"));const h=t.createCommandEncoder();o.compute(h,r),a.render(h),t.queue.submit([h.finish()])};requestAnimationFrame(S)})).catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
