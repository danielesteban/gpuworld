!function(){"use strict";var e=1e-6,n="undefined"!=typeof Float32Array?Float32Array:Array,t=Math.PI/180;function i(){var e=new n(16);return n!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.hypot||(Math.hypot=function(){for(var e=0,n=arguments.length;n--;)e+=arguments[n]*arguments[n];return Math.sqrt(e)});var o=function(e,n,t,i,o){var r,a=1/Math.tan(n/2);return e[0]=a/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e};function r(){var e=new n(3);return n!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function a(e,t,i){var o=new n(3);return o[0]=e,o[1]=t,o[2]=i,o}function s(e,n,t,i){return e[0]=n,e[1]=t,e[2]=i,e}function u(e,n,t,i){return e[0]=n[0]+t[0]*i,e[1]=n[1]+t[1]*i,e[2]=n[2]+t[2]*i,e}function c(){var e=new n(2);return n!=Float32Array&&(e[0]=0,e[1]=0),e}function p(e){var t=new n(2);return t[0]=e[0],t[1]=e[1],t}function l(e,t){var i=new n(2);return i[0]=e,i[1]=t,i}function d(e,n,t){return e[0]=n,e[1]=t,e}function h(e,n,t){return e[0]=n[0]+t[0],e[1]=n[1]+t[1],e}function f(e){var n=e[0],t=e[1];return Math.hypot(n,t)}r(),function(){var e=c()}();const v=a(0,1,0);class m{constructor({device:e,aspect:n=1,fov:t=75,near:o=.1,far:a=1e3}){this.device=e,this.buffer=e.createBuffer({size:32*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM}),this.aspect=n,this.fov=t,this.near=o,this.far=a,this.projectionMatrix=i(),this.viewMatrix=i(),this.position=r(),this.target=r()}updateProjection(){const{device:e,buffer:n,projectionMatrix:i,aspect:r,fov:a,near:s,far:u}=this;o(i,a*t,r,s,u),e.queue.writeBuffer(n,0,i)}updateView(){const{device:n,buffer:t,viewMatrix:i,position:o,target:r}=this;var a,s,u,c,p,l,d,h,f,m,g,x,k,y,b,w,z,S,E,_,M,P,B;a=i,u=r,c=v,b=(s=o)[0],w=s[1],z=s[2],S=c[0],E=c[1],_=c[2],M=u[0],P=u[1],B=u[2],Math.abs(b-M)<e&&Math.abs(w-P)<e&&Math.abs(z-B)<e?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(a):(g=b-M,x=w-P,k=z-B,p=E*(k*=y=1/Math.hypot(g,x,k))-_*(x*=y),l=_*(g*=y)-S*k,d=S*x-E*g,(y=Math.hypot(p,l,d))?(p*=y=1/y,l*=y,d*=y):(p=0,l=0,d=0),h=x*d-k*l,f=k*p-g*d,m=g*l-x*p,(y=Math.hypot(h,f,m))?(h*=y=1/y,f*=y,m*=y):(h=0,f=0,m=0),a[0]=p,a[1]=h,a[2]=g,a[3]=0,a[4]=l,a[5]=f,a[6]=x,a[7]=0,a[8]=d,a[9]=m,a[10]=k,a[11]=0,a[12]=-(p*b+l*w+d*z),a[13]=-(h*b+f*w+m*z),a[14]=-(g*b+x*w+k*z),a[15]=1),n.queue.writeBuffer(t,64,i)}}const g=r();class x{constructor({position:e,target:t}){var i,o;this.target=t,this.keyboard=r(),this.pointer={movement:c(),position:c()},this.look={state:l(.5*Math.PI,0),target:l(.5*Math.PI,0)},this.position={state:e,target:(i=e,o=new n(3),o[0]=i[0],o[1]=i[1],o[2]=i[2],o)},this.speed={state:8,target:8},this.vectors={forward:r(),right:r(),worldUp:a(0,1,0)},t.addEventListener("contextmenu",this.onContextMenu.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1),t.addEventListener("mousedown",this.onMouseDown.bind(this),!1),window.addEventListener("mousemove",this.onMouseMove.bind(this),!1),window.addEventListener("mouseup",this.onMouseUp.bind(this),!1),window.addEventListener("wheel",this.onMouseWheel.bind(this),{passive:!1}),document.addEventListener("pointerlockchange",this.onPointerLock.bind(this),!1)}lock(){const{isLocked:e,target:n}=this;e||n.requestPointerLock()}unlock(){const{isLocked:e}=this;e&&document.exitPointerLock()}onContextMenu(e){e.preventDefault()}onKeyDown({key:e,repeat:n,target:t}){const{isLocked:i,keyboard:o}=this;if(i&&!n&&"INPUT"!==t.tagName)switch(e.toLowerCase()){case"w":o[2]=1;break;case"s":o[2]=-1;break;case"a":o[0]=-1;break;case"d":o[0]=1;break;case" ":o[1]=1;break;case"shift":o[1]=-1}}onKeyUp({key:e}){const{isLocked:n,keyboard:t}=this;if(n)switch(e.toLowerCase()){case"w":t[2]>0&&(t[2]=0);break;case"s":t[2]<0&&(t[2]=0);break;case"a":t[0]<0&&(t[0]=0);break;case"d":t[0]>0&&(t[0]=0);break;case" ":t[1]>0&&(t[1]=0);break;case"shift":t[1]<0&&(t[1]=0)}}onMouseDown({button:e}){const{isLocked:n,pointer:t}=this;n?t.isDown=0===e:this.lock()}onMouseMove({clientX:e,clientY:n,movementX:t,movementY:i}){const{sensitivity:o}=x,{isLocked:r,pointer:{movement:a,position:s}}=this;r&&(a[0]-=t*o.look,a[1]+=i*o.look,d(s,e/window.innerWidth*2-1,-n/window.innerHeight*2+1))}onMouseUp({button:e}){const{isLocked:n,pointer:t}=this;n&&0===e&&(t.isDown=!1)}onMouseWheel(e){const{sensitivity:n,minSpeed:t,speedRange:i}=x,{isLocked:o,speed:r}=this;if(e.ctrlKey&&e.preventDefault(),!o)return;const a=Math.min(Math.max((Math.log(r.target)-t)/i-e.deltaY*n.speed,0),1);r.target=Math.exp(t+a*i)}onPointerLock(){const{keyboard:e,pointer:n}=this;this.isLocked=!!document.pointerLockElement,this.isLocked||(s(e,0,0,0),n.isDown=!1)}update(e){const{minPhi:n,maxPhi:t}=x,{isLocked:i,keyboard:o,pointer:r,look:a,position:c,speed:p,vectors:l}=this;i&&(a.target[1]+=r.movement[0],a.target[0]=Math.min(Math.max(a.target[0]+r.movement[1],n),t));const h=1-Math.exp(-20*e);var f,v,m,k,y,b;f=a.state,v=a.state,m=a.target,k=h,y=v[0],b=v[1],f[0]=y+k*(m[0]-y),f[1]=b+k*(m[1]-b),p.state=p.state*(1-h)+p.target*h,d(r.movement,0,0),s(l.forward,Math.sin(a.state[0])*Math.sin(a.state[1]),Math.cos(a.state[0]),Math.sin(a.state[0])*Math.cos(a.state[1])),function(e,n,t){var i=n[0],o=n[1],r=n[2],a=t[0],s=t[1],u=t[2];e[0]=o*u-r*s,e[1]=r*a-i*u,e[2]=i*s-o*a}(l.right,l.forward,l.worldUp),0===o[0]&&0===o[1]&&0===o[2]||(s(g,0,0,0),u(g,g,l.right,o[0]),u(g,g,l.worldUp,o[1]),u(g,g,l.forward,o[2]),function(e,n){var t=n[0],i=n[1],o=n[2],r=t*t+i*i+o*o;r>0&&(r=1/Math.sqrt(r)),e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r}(g,g),u(c.target,c.target,g,e*p.state)),function(e,n,t,i){var o=n[0],r=n[1],a=n[2];e[0]=o+i*(t[0]-o),e[1]=r+i*(t[1]-r),e[2]=a+i*(t[2]-a)}(c.state,c.state,c.target,1-Math.exp(-10*e))}}x.sensitivity={look:.003,speed:3e-4},x.minPhi=.01,x.maxPhi=Math.PI-.01,x.minSpeed=Math.log(4),x.maxSpeed=Math.log(32),x.speedRange=x.maxSpeed-x.minSpeed;class k{constructor({device:e,format:n}){this.device=e,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},this.geometry=(e=>{const n=e.createBuffer({size:18*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1]),n.unmap(),n})(e),this.pipeline=e.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:3*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"}]}],entryPoint:"main",module:e.createShaderModule({code:"\n@vertex\nfn main(@location(0) position : vec4<f32>) -> @builtin(position) vec4<f32> {\n  return position;\n}\n"})},fragment:{entryPoint:"main",module:e.createShaderModule({code:"\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n  position : vec3<f32>,\n  direction : vec3<f32>,\n}\n\nstruct Effect {\n  color : vec3<f32>,\n  intensity : f32,\n  depthScale : f32,\n  normalScale : f32,\n}\n\nconst effect : Effect = Effect(\n  vec3<f32>(0, 0, 0),\n  0.1,\n  0.5,\n  0.5,\n);\n\nconst offset : vec3<i32> = vec3<i32>(1, 1, 0);\n\nfn edgesDepth(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : f32 = textureLoad(positionTexture, pixel, 0).w;\n  var pixelLeft : f32 = textureLoad(positionTexture, pixel - offset.xz, 0).w;\n  var pixelRight : f32 = textureLoad(positionTexture, pixel + offset.xz, 0).w;\n  var pixelUp : f32 = textureLoad(positionTexture, pixel + offset.zy, 0).w;\n  var pixelDown : f32 = textureLoad(positionTexture, pixel - offset.zy, 0).w;\n  return (\n    abs(pixelLeft    - pixelCenter) \n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter) \n  ) * effect.depthScale;\n}\n\nfn edgesNormal(pixel : vec2<i32>) -> f32 {\n  var pixelCenter : vec3<f32> = textureLoad(normalTexture, pixel, 0).xyz;\n  var pixelLeft : vec3<f32> = textureLoad(normalTexture, pixel - offset.xz, 0).xyz;\n  var pixelRight : vec3<f32> = textureLoad(normalTexture, pixel + offset.xz, 0).xyz;\n  var pixelUp : vec3<f32> = textureLoad(normalTexture, pixel + offset.zy, 0).xyz;\n  var pixelDown : vec3<f32> = textureLoad(normalTexture, pixel - offset.zy, 0).xyz;\n  var edge : vec3<f32> = (\n    abs(pixelLeft    - pixelCenter)\n    + abs(pixelRight - pixelCenter) \n    + abs(pixelUp    - pixelCenter) \n    + abs(pixelDown  - pixelCenter)\n  );\n  return (edge.x + edge.y + edge.z) * effect.normalScale;\n}\n\n@group(0) @binding(0) var colorTexture : texture_2d<f32>;\n@group(0) @binding(1) var normalTexture : texture_2d<f32>;\n@group(0) @binding(2) var positionTexture : texture_2d<f32>;\n\n@fragment\nfn main(@builtin(position) uv : vec4<f32>) -> @location(0) vec4<f32> {\n  var pixel : vec2<i32> = vec2<i32>(floor(uv.xy));\n  var color : vec3<f32> = textureLoad(colorTexture, pixel, 0).xyz;\n  color = mix(color, effect.color, clamp(max(edgesDepth(pixel), edgesNormal(pixel)), 0, 1) * effect.intensity);\n  return vec4<f32>(color, 1);\n}\n"}),targets:[{format:n}]},primitive:{topology:"triangle-list"}})}bindTextures([e,n,t]){const{device:i,pipeline:o}=this;this.bindings=i.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:e.resolveTarget},{binding:1,resource:n.resolveTarget},{binding:2,resource:t.resolveTarget}]})}render(e,n){const{bindings:t,descriptor:i,geometry:o,pipeline:r}=this;i.colorAttachments[0].view=n;const a=e.beginRenderPass(i);a.setPipeline(r),a.setBindGroup(0,t),a.setVertexBuffer(0,o),a.draw(6,1,0,0),a.end()}}var y="\nfn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }\nfn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfn noise3(p: vec3<f32>) -> f32 {\n  let a = floor(p);\n  var d: vec3<f32> = p - a;\n  d = d * d * (3. - 2. * d);\n\n  let b = a.xxyy + vec4<f32>(0., 1., 0., 1.);\n  let k1 = permute4(b.xyxy);\n  let k2 = permute4(k1.xyxy + b.zzww);\n\n  let c = k2 + a.zzzz;\n  let k3 = permute4(c);\n  let k4 = permute4(c + 1.);\n\n  let o1 = fract(k3 * (1. / 41.));\n  let o2 = fract(k4 * (1. / 41.));\n\n  let o3 = o2 * d.z + o1 * (1. - d.z);\n  let o4 = o3.yw * d.x + o3.xz * (1. - d.x);\n\n  return o4.y * d.y + o4.x * (1. - d.y);\n}\n\nfn simplexNoise3(v: vec3<f32>) -> f32 {\n  let C = vec2<f32>(1. / 6., 1. / 3.);\n  let D = vec4<f32>(0., 0.5, 1., 2.);\n\n  var i: vec3<f32>  = floor(v + dot(v, C.yyy));\n  let x0 = v - i + dot(i, C.xxx);\n\n  let g = step(x0.yzx, x0.xyz);\n  let l = 1.0 - g;\n  let i1 = min(g.xyz, l.zxy);\n  let i2 = max(g.xyz, l.zxy);\n\n  let x1 = x0 - i1 + 1. * C.xxx;\n  let x2 = x0 - i2 + 2. * C.xxx;\n  let x3 = x0 - 1. + 3. * C.xxx;\n\n  i = i % vec3<f32>(289.);\n  let p = permute4(permute4(permute4(\n      i.z + vec4<f32>(0., i1.z, i2.z, 1. )) +\n      i.y + vec4<f32>(0., i1.y, i2.y, 1. )) +\n      i.x + vec4<f32>(0., i1.x, i2.x, 1. ));\n\n  var n_: f32 = 1. / 7.;\n  let ns = n_ * D.wyz - D.xzx;\n\n  let j = p - 49. * floor(p * ns.z * ns.z);\n\n  let x_ = floor(j * ns.z);\n  let y_ = floor(j - 7.0 * x_);\n\n  let x = x_ *ns.x + ns.yyyy;\n  let y = y_ *ns.x + ns.yyyy;\n  let h = 1.0 - abs(x) - abs(y);\n\n  let b0 = vec4<f32>( x.xy, y.xy );\n  let b1 = vec4<f32>( x.zw, y.zw );\n\n  let s0 = floor(b0)*2.0 + 1.0;\n  let s1 = floor(b1)*2.0 + 1.0;\n  let sh = -step(h, vec4<f32>(0.));\n\n  let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  var p0: vec3<f32> = vec3<f32>(a0.xy, h.x);\n  var p1: vec3<f32> = vec3<f32>(a0.zw, h.y);\n  var p2: vec3<f32> = vec3<f32>(a1.xy, h.z);\n  var p3: vec3<f32> = vec3<f32>(a1.zw, h.w);\n\n  let norm = taylorInvSqrt4(vec4<f32>(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n  p0 = p0 * norm.x;\n  p1 = p1 * norm.y;\n  p2 = p2 * norm.z;\n  p3 = p3 * norm.w;\n\n  var m: vec4<f32> = 0.6 - vec4<f32>(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  m = max(m, vec4<f32>(0.));\n  m = m * m;\n  return 42. * dot(m * m, vec4<f32>(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n";const b=({count:e,width:n,height:t,generator:i})=>`\nstruct Atlas {\n  count : i32,\n  width : i32,\n  height : i32,\n  stride : i32,\n  length : i32,\n}\n\nconst atlas : Atlas = Atlas(\n  ${e},\n  ${n},\n  ${t},\n  ${n*t},\n  ${e*n*t},\n);\n\n@group(0) @binding(0) var texture : texture_storage_2d_array<rgba8unorm, write>;\n\n${y}\n\n${i}\n\n@compute @workgroup_size(256)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var id : i32 = i32(GlobalInvocationID.x);\n  if (id >= atlas.length) {\n    return;\n  }\n  var tex : i32 = id / atlas.stride;\n  var index : i32 = id - tex * atlas.stride;\n  var y : i32 = index / atlas.width;\n  var pixel : vec2<i32> = vec2<i32>(index - y * atlas.width, y);\n  textureStore(texture, pixel, tex, getColorAt(tex, pixel));\n}\n`;class w{constructor({device:e,count:n=3,width:t=16,height:i=16}){this.device=e,this.count=n,this.width=t,this.height=i,this.texture=e.createTexture({dimension:"2d",size:[t,i,n],format:"rgba8unorm",usage:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.workgroups=Math.ceil(n*t*i/256)}compute(e="\nfn getColorAt(texture : i32, pixel : vec2<i32>) -> vec4<f32> {\n  if (texture == 0 || (texture == 2 && pixel.y > 4 - i32(4 * noise3(vec3<f32>(vec2<f32>(pixel), 0))))) {\n    return vec4<f32>(1);\n  }\n  return vec4<f32>(0.6, 1.0, 0.6, 1.0);\n}\n"){const{device:n,count:t,width:i,height:o,texture:r,workgroups:a}=this,s=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:b({count:t,width:i,height:o,generator:e})})}}),u=n.createCommandEncoder(),c=u.beginComputePass();c.setPipeline(s),c.setBindGroup(0,n.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:r.createView()}]})),c.dispatchWorkgroups(a),c.end(),n.queue.submit([u.finish()])}}class z{constructor({camera:e,device:n,samples:t}){this.atlas=new w({device:n}),this.geometry=(e=>{const n=e.createBuffer({size:30*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});return new Float32Array(n.getMappedRange()).set([-.5,-.5,.5,0,1,.5,-.5,.5,1,1,.5,.5,.5,1,0,.5,.5,.5,1,0,-.5,.5,.5,0,0,-.5,-.5,.5,0,1]),n.unmap(),n})(n),this.pipeline=n.createRenderPipeline({layout:"auto",vertex:{buffers:[{arrayStride:5*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32x2"}]},{arrayStride:6*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:2,offset:0,format:"float32x3"},{shaderLocation:3,offset:3*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:4,offset:4*Float32Array.BYTES_PER_ELEMENT,format:"float32"},{shaderLocation:5,offset:5*Float32Array.BYTES_PER_ELEMENT,format:"float32"}]}],entryPoint:"main",module:n.createShaderModule({code:"\nstruct VertexInput {\n  @location(0) position : vec3<f32>,\n  @location(1) uv : vec2<f32>,\n  @location(2) origin : vec3<f32>,\n  @location(3) light : f32,\n  @location(4) face : f32,\n  @location(5) texture : f32,\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) worldPosition : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) depth : f32,\n  @location(4) @interpolate(flat) light : vec3<f32>,\n  @location(5) @interpolate(flat) texture : i32,\n}\n\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\nconst faceNormal : vec3<f32> = vec3<f32>(0, 0, 1);\nconst sunlightColor : vec3<f32> = vec3<f32>(0.9, 0.8, 0.4);\nconst PI : f32 = 3.141592653589793;\n\nfn rotateX(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    1, 0, 0,\n    0, c, s,\n    0, -s, c,\n  );\n}\n\nfn rotateY(rad : f32) -> mat3x3<f32> {\n  var c : f32 = cos(rad);\n  var s : f32 = sin(rad);\n  return mat3x3<f32>(\n    c, 0, -s,\n    0, 1, 0,\n    s, 0, c,\n  );\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n\n@vertex\nfn main(voxel : VertexInput) -> VertexOutput {\n  var rotation : mat3x3<f32>;\n  switch (i32(voxel.face)) {\n    default {\n      rotation = mat3x3<f32>(\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1,\n      );\n    }\n    case 1 {\n      rotation = rotateX(PI * -0.5);\n    }\n    case 2 {\n      rotation = rotateX(PI * 0.5);\n    }\n    case 3 {\n      rotation = rotateY(PI * -0.5);\n    }\n    case 4 {\n      rotation = rotateY(PI * 0.5);\n    }\n    case 5 {\n      rotation = rotateY(PI);\n    }\n  }\n  var position : vec4<f32> = vec4<f32>(rotation * voxel.position + voxel.origin, 1);\n  var mvPosition : vec4<f32> = camera.view * position;\n  var out : VertexOutput;\n  out.position = camera.projection * mvPosition;\n  out.worldPosition = position.xyz;\n  out.normal = normalize(rotation * faceNormal);\n  out.uv = voxel.uv;\n  out.depth = -mvPosition.z;\n  out.light = sunlightColor * pow(voxel.light, 8);\n  out.texture = i32(voxel.texture);\n  return out;\n}\n"})},fragment:{entryPoint:"main",module:n.createShaderModule({code:"\nstruct FragmentInput {\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n  @location(3) depth : f32,\n  @location(4) @interpolate(flat) light : vec3<f32>,\n  @location(5) @interpolate(flat) texture : i32,\n}\n\nstruct FragmentOutput {\n  @location(0) color : vec4<f32>,\n  @location(1) normal : vec4<f32>,\n  @location(2) position : vec4<f32>,\n}\n\n@group(0) @binding(1) var atlas : texture_2d_array<f32>;\n@group(0) @binding(2) var atlasSampler : sampler;\n\n@fragment\nfn main(face : FragmentInput) -> FragmentOutput {\n  var output : FragmentOutput;\n  output.color = textureSample(atlas, atlasSampler, face.uv, face.texture);\n  output.color *= vec4<f32>(face.light, 1);\n  output.normal = vec4<f32>(normalize(face.normal), 1);\n  output.position = vec4<f32>(face.position, face.depth);\n  return output;\n}\n"}),targets:[{format:"rgba8unorm"},{format:"rgba16float"},{format:"rgba16float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus"},multisample:{count:t}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.buffer}},{binding:1,resource:this.atlas.texture.createView()},{binding:2,resource:n.createSampler()}]})}render(e,n){const{bindings:t,geometry:i,pipeline:o}=this;e.setPipeline(o),e.setBindGroup(0,t),e.setVertexBuffer(0,i),n.forEach((({faces:n})=>{e.setVertexBuffer(1,n,16),e.drawIndirect(n,0)}))}}class S{constructor({adapter:e,camera:n,device:t,samples:i=4}){const o=navigator.gpu.getPreferredCanvasFormat(e);this.canvas=document.createElement("canvas"),this.canvas.width=Math.floor(window.innerWidth*(window.devicePixelRatio||1)),this.canvas.height=Math.floor(window.innerHeight*(window.devicePixelRatio||1)),this.context=this.canvas.getContext("webgpu"),this.context.configure({alphaMode:"opaque",device:t,format:o}),this.camera=n,this.device=t,this.samples=i,this.textures=new Map,this.descriptor={colorAttachments:[{clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"},{clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.postprocessing=new k({device:t,format:o}),this.voxels=new z({camera:n,device:t,samples:i})}render(e,n){const{context:t,descriptor:i,postprocessing:o,voxels:r}=this,a=e.beginRenderPass(i);r.render(a,n),a.end(),o.render(e,t.getCurrentTexture().createView())}setClearColor(e,n,t){const{descriptor:{colorAttachments:[{clearValue:i}]}}=this;i.r=e,i.g=n,i.b=t}setSize(e,n){const{camera:t,canvas:i,descriptor:o,postprocessing:r}=this,a=window.devicePixelRatio||1,s=[Math.floor(e*a),Math.floor(n*a)];i.width=s[0],i.height=s[1],i.style.width=`${e}px`,i.style.height=`${n}px`,t.aspect=e/n,t.updateProjection(),this.updateTexture(o.colorAttachments[0],"rgba8unorm","color",s),this.updateTexture(o.colorAttachments[1],"rgba16float","normal",s),this.updateTexture(o.colorAttachments[2],"rgba16float","position",s),this.updateTexture(o.depthStencilAttachment,"depth24plus","depth",s,!1),r.bindTextures(o.colorAttachments)}updateTexture(e,n,t,i,o=!0){const{device:r,samples:a,textures:s}=this,u=s.get(t);u&&u.forEach((e=>e.destroy())),s.set(t,[a,...o?[1]:[]].map((t=>{const o=r.createTexture({format:n,sampleCount:t,size:i,usage:GPUTextureUsage.RENDER_ATTACHMENT|(1===t?GPUTextureUsage.TEXTURE_BINDING:0)});return 1===t?e.resolveTarget=o.createView():e.view=o.createView(),o})))}}class E{constructor({chunkSize:e,device:n,position:t}){this.bindings={},this.position=p(t),this.data=n.createBuffer({mappedAtCreation:!0,size:(12+e.x*e.y*e.z+e.x*e.y*e.z+2*(1+e.x*e.z*3)+1+1)*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE}),new Uint32Array(this.data.getMappedRange(0,3*Uint32Array.BYTES_PER_ELEMENT)).set([e.x,e.y,e.z]),this.data.unmap(),this.faces=n.createBuffer({size:4*Uint32Array.BYTES_PER_ELEMENT+6*Math.ceil(e.x*e.y*e.z*.5)*6*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX}),this.offset=n.createBuffer({mappedAtCreation:!0,size:3*Int32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM}),new Int32Array(this.offset.getMappedRange()).set([t[0]*e.x,0,t[1]*e.z]),this.offset.unmap()}}E.compute=({atomicBounds:e,atomicInstanceCount:n,atomicLight:t,atomicQueueCount:i,chunkSize:o})=>`\n  const chunkSize : vec3<i32> = vec3<i32>(${o.x}, ${o.y}, ${o.z});\n  const maxLight : u32 = 255;\n\n  struct Bounds {\n    min : array<${e?"atomic<u32>":"u32"}, 3>,\n    max : array<${e?"atomic<u32>":"u32"}, 3>,\n    center : vec3<f32>,\n    radius : f32,\n  }\n\n  struct Faces {\n    vertexCount : u32,\n    instanceCount : ${n?"atomic<u32>":"u32"},\n    firstVertex : u32,\n    firstInstance : u32,\n    data : array<f32>,\n  }\n\n  struct Queue {\n    count : ${i?"atomic<u32>":"u32"},\n    data : array<u32, ${o.x*o.z*3}>,\n  }\n\n  struct Chunk {\n    bounds : Bounds,\n    voxels : array<u32, ${o.x*o.y*o.z}>,\n    light : array<${t?"atomic<u32>":"u32"}, ${o.x*o.y*o.z}>,\n    queues : array<Queue, 2>,\n    queue : u32,\n    remesh : u32,\n  }\n\n  fn getVoxel(pos : vec3<i32>) -> u32 {\n    return u32(pos.z * chunkSize.x * chunkSize.y + pos.y * chunkSize.x + pos.x);\n  }\n\n  fn getPos(voxel : u32) -> vec3<i32> {\n    var o : i32 = i32(voxel) % (chunkSize.x * chunkSize.y);\n    return vec3<i32>(\n      o % chunkSize.x,\n      o / chunkSize.x,\n      i32(voxel) / (chunkSize.x * chunkSize.y),\n    );\n  }\n`;class _{constructor({device:e,camera:n}){this.buffer=e.createBuffer({size:24*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),this.pipeline=e.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:e.createShaderModule({code:"\nstruct Camera {\n  projection : mat4x4<f32>,\n  view : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> camera : Camera;\n@group(0) @binding(1) var<storage, read_write> frustum : array<vec4<f32>, 6>;\n\nfn update(index : i32, plane : vec4<f32>) {\n  frustum[index] = plane * (1 / length(plane.xyz));\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  var m : mat4x4<f32> = camera.projection * camera.view;\n  update(0, vec4<f32>(m[0].w - m[0].x, m[1].w - m[1].x, m[2].w - m[2].x, m[3].w - m[3].x));\n  update(1, vec4<f32>(m[0].w + m[0].x, m[1].w + m[1].x, m[2].w + m[2].x, m[3].w + m[3].x));\n  update(2, vec4<f32>(m[0].w + m[0].y, m[1].w + m[1].y, m[2].w + m[2].y, m[3].w + m[3].y));\n  update(3, vec4<f32>(m[0].w - m[0].y, m[1].w - m[1].y, m[2].w - m[2].y, m[3].w - m[3].y));\n  update(4, vec4<f32>(m[0].w - m[0].z, m[1].w - m[1].z, m[2].w - m[2].z, m[3].w - m[3].z));\n  update(5, vec4<f32>(m[0].w + m[0].z, m[1].w + m[1].z, m[2].w + m[2].z, m[3].w + m[3].z));\n}\n"})}}),this.bindings=e.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.buffer}},{binding:1,resource:{buffer:this.buffer}}]})}compute(e){const{bindings:n,pipeline:t}=this;e.setPipeline(t),e.setBindGroup(0,n),e.dispatchWorkgroups(1)}}const M=({chunkSize:e})=>`\n${E.compute({atomicQueueCount:!0,atomicLight:!0,chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> chunk_east : Chunk;\n@group(1) @binding(2) var<storage, read_write> chunk_west : Chunk;\n@group(1) @binding(3) var<storage, read_write> chunk_north : Chunk;\n@group(1) @binding(4) var<storage, read_write> chunk_south : Chunk;\n\nfn flood(pos : vec3<i32>, level : u32) {\n  // I really tried to make this with pointers\n  // and a single logic block but I couldn't manage to\n  // pass a ptr<storage, Chunk, read_write> to a function\n  if (pos.x == -1) {\n    var voxel : u32 = getVoxel(vec3<i32>(chunkSize.x - 1, pos.y, pos.z));\n    if (chunk_west.voxels[voxel] != 0) {\n      chunk_west.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_west.light[voxel], level) < level) {\n      chunk_west.queues[chunk_west.queue].data[atomicAdd(&(chunk_west.queues[chunk_west.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.x == chunkSize.x) {\n    var voxel : u32 = getVoxel(vec3<i32>(0, pos.y, pos.z));\n    if (chunk_east.voxels[voxel] != 0) {\n      chunk_east.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_east.light[voxel], level) < level) {\n      chunk_east.queues[chunk_east.queue].data[atomicAdd(&(chunk_east.queues[chunk_east.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == -1) {\n    var voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, chunkSize.z - 1));\n    if (chunk_south.voxels[voxel] != 0) {\n      chunk_south.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_south.light[voxel], level) < level) {\n      chunk_south.queues[chunk_south.queue].data[atomicAdd(&(chunk_south.queues[chunk_south.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  if (pos.z == chunkSize.z) {\n    var voxel : u32 = getVoxel(vec3<i32>(pos.x, pos.y, 0));\n    if (chunk_north.voxels[voxel] != 0) {\n      chunk_north.remesh = 1;\n      return;\n    }\n    if (atomicMax(&chunk_north.light[voxel], level) < level) {\n      chunk_north.queues[chunk_north.queue].data[atomicAdd(&(chunk_north.queues[chunk_north.queue].count), 1)] = voxel;\n    }\n    return;\n  }\n  var voxel : u32 = getVoxel(pos);\n  if (chunk.voxels[voxel] != 0) {\n    return;\n  }\n  if (atomicMax(&chunk.light[voxel], level) < level) {\n    chunk.queues[chunk.queue].data[atomicAdd(&(chunk.queues[chunk.queue].count), 1)] = voxel;\n  }\n}\n\nconst neighbors = array<vec3<i32>, 6>(\n  vec3<i32>(0, -1, 0),\n  vec3<i32>(1, 0, 0),\n  vec3<i32>(-1, 0, 0),\n  vec3<i32>(0, 0, 1),\n  vec3<i32>(0, 0, -1),\n  vec3<i32>(0, 1, 0),\n);\n\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  if (GlobalInvocationID.x >= uniforms.count) {\n    return;\n  }\n  var voxel : u32 = chunk.queues[uniforms.queue].data[GlobalInvocationID.x];\n  var light : u32 = atomicLoad(&chunk.light[voxel]);\n  var pos : vec3<i32> = getPos(voxel);\n  for (var n : i32 = 0; n < 6; n++) {\n    var npos = pos + neighbors[n];\n    if (npos.y == -1 || npos.y == chunkSize.y) {\n      continue;\n    }\n    var level : u32 = light;\n    if (n != 0 || level < maxLight) {\n      level -= 1;\n    }\n    flood(npos, level);\n  }\n}\n`;class P{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:M({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}}]}),this.workgroups=i}compute(e,n){const{bindings:t,device:i,pipeline:o,workgroups:r}=this;n.bindings.lightingCompute||(n.bindings.lightingCompute=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[n,...n.neighbors].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingCompute),e.dispatchWorkgroupsIndirect(r,0)}}const B=({chunkSize:e})=>`\n${E.compute({chunkSize:e})}\n\nstruct Uniforms {\n  count : u32,\n  queue : u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> uniforms : Uniforms;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n\n@compute @workgroup_size(1)\nfn main() {\n  var count : u32 = chunk.queues[chunk.queue].count;\n  if (count == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n\n  uniforms.count = count;\n  uniforms.queue = chunk.queue;\n\n  workgroups[0] = u32(ceil(f32(count) / 64));\n  workgroups[1] = 1;\n  workgroups[2] = 1;\n\n  var next : u32 = (chunk.queue + 1) % 2;\n  chunk.queue = next;\n  chunk.queues[next].count = 0;\n\n  chunk.remesh = 1;\n}\n`;class C{constructor({chunkSize:e,device:n,uniforms:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:B({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.lightingSetup||(n.bindings.lightingSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.lightingSetup),e.dispatchWorkgroups(1)}}class L{constructor({chunkSize:e,device:n}){const t=n.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE}),i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.propagate=new P({chunkSize:e,device:n,uniforms:t,workgroups:i}),this.setup=new C({chunkSize:e,device:n,uniforms:t,workgroups:i})}compute(e,n){const{propagate:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const T=({chunkSize:e})=>`\n${E.compute({atomicInstanceCount:!0,chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read> chunk : Chunk;\n@group(0) @binding(1) var<storage, read> chunk_east : Chunk;\n@group(0) @binding(2) var<storage, read> chunk_west : Chunk;\n@group(0) @binding(3) var<storage, read> chunk_north : Chunk;\n@group(0) @binding(4) var<storage, read> chunk_south : Chunk;\n@group(0) @binding(5) var<storage, read_write> faces : Faces;\n@group(0) @binding(6) var<uniform> position : vec3<i32>;\n\nfn isAir(pos : vec3<i32>) -> bool {\n  if (\n    pos.y < 0\n    || (pos.x < 0 && pos.z < 0)\n    || (pos.x >= chunkSize.x && pos.z < 0)\n    || (pos.x < 0 && pos.z >= chunkSize.z)\n    || (pos.x >= chunkSize.x && pos.z >= chunkSize.z)\n  ) {\n    return false;\n  }\n  if (pos.y >= chunkSize.y) {\n    return true;\n  }\n  if (pos.x < 0) {\n    return chunk_west.voxels[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))] == 0;\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.voxels[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))] == 0;\n  }\n  if (pos.z < 0) {\n    return chunk_south.voxels[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))] == 0;\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.voxels[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))] == 0;\n  }\n  return chunk.voxels[getVoxel(pos)] == 0;\n}\n\nfn getLight(pos : vec3<i32>) -> u32 {\n  if (pos.y < 0) {\n    return 0;\n  }\n  if (pos.y >= chunkSize.y) {\n    return maxLight;\n  }\n  if (pos.x < 0) {\n    return chunk_west.light[getVoxel(pos + vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.x >= chunkSize.x) {\n    return chunk_east.light[getVoxel(pos - vec3<i32>(chunkSize.x, 0, 0))];\n  }\n  if (pos.z < 0) {\n    return chunk_south.light[getVoxel(pos + vec3<i32>(0, 0, chunkSize.z))];\n  }\n  if (pos.z >= chunkSize.z) {\n    return chunk_north.light[getVoxel(pos - vec3<i32>(0, 0, chunkSize.z))];\n  }\n  return chunk.light[getVoxel(pos)]; \n}\n\nstruct Normals {\n  f : vec3<i32>,\n  u : vec3<i32>,\n  v : vec3<i32>,\n}\n\nconst faceNormals = array<Normals, 6>(\n  Normals(vec3<i32>(0, 0, 1), vec3<i32>(0, 1, 0), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, 1, 0), vec3<i32>(0, 0, -1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(0, -1, 0), vec3<i32>(0, 0, 1), vec3<i32>(1, 0, 0)),\n  Normals(vec3<i32>(-1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(1, 0, 0), vec3<i32>(0, 1, 0), vec3<i32>(0, 0, 1)),\n  Normals(vec3<i32>(0, 0, -1), vec3<i32>(0, 1, 0), vec3<i32>(-1, 0, 0)),\n);\n\nconst neighbors = array<vec2<i32>, 5>(\n  vec2<i32>(0, 0),\n  vec2<i32>(-1, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, -1),\n  vec2<i32>(0, 1),\n);\n\nfn getLightAvg(pos : vec3<i32>, u : vec3<i32>, v : vec3<i32>) -> f32 {\n  var level : f32;\n  var count : i32;\n  for (var n : i32 = 0; n < 5; n++) {\n    var nuv = neighbors[n];\n    var npos : vec3<i32> = pos + u * nuv.x + v * nuv.y;\n    if (n == 0 || isAir(npos)) {\n      var nlight : u32 = getLight(npos);\n      if (nlight != 0) {\n        level += f32(nlight);\n        count++;\n      }\n    }\n  }\n  return level / f32(max(count, 1)) / f32(maxLight);\n}\n\nfn getTexture(face : i32, value : u32) -> i32 {\n  if (value == 1 || face == 2) {\n    return 0;\n  }\n  if (value == 2 && face == 1) {\n    return 1;\n  }\n  return 2;\n}\n\nfn pushFace(pos : vec3<i32>, face : i32, texture : i32, light : f32) {\n  if (light == 0) {\n    return;\n  }\n  var offset : u32 = atomicAdd(&(faces.instanceCount), 1) * 6;\n  faces.data[offset] = f32(pos.x) + 0.5;\n  faces.data[offset + 1] = f32(pos.y) + 0.5;\n  faces.data[offset + 2] = f32(pos.z) + 0.5;\n  faces.data[offset + 3] = light;\n  faces.data[offset + 4] = f32(face);\n  faces.data[offset + 5] = f32(texture);\n}\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  var value : u32 = chunk.voxels[getVoxel(pos)];\n  if (value != 0) {\n    for (var face : i32 = 0; face < 6; face++) {\n      var npos : vec3<i32> = pos + faceNormals[face].f;\n      if (isAir(npos)) {\n        pushFace(\n          position + pos,\n          face,\n          getTexture(face, value),\n          getLightAvg(npos, faceNormals[face].u, faceNormals[face].v)\n        );\n      }\n    }\n  }\n}\n`;class G{constructor({chunkSize:e,device:n,workgroups:t}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:T({chunkSize:e})}),entryPoint:"main"}}),this.workgroups=t}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.mesherCompute||(n.bindings.mesherCompute=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[n,...n.neighbors,{data:n.faces},{data:n.offset}].map((({data:e},n)=>({binding:n,resource:{buffer:e}})))})),e.setPipeline(i),e.setBindGroup(0,n.bindings.mesherCompute),e.dispatchWorkgroupsIndirect(o,0)}}const A=({chunkSize:e})=>`\n${E.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<uniform> frustum : array<vec4<f32>, 6>;\n@group(0) @binding(1) var<storage, read_write> workgroups : array<u32, 3>;\n@group(1) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(1) @binding(1) var<storage, read_write> faces : Faces;\n\nfn isInFrustum() -> bool {\n  for (var i : i32 = 0; i < 6; i++) {\n    var plane : vec4<f32> = frustum[i];\n    var distance : f32 = dot(plane.xyz, chunk.bounds.center) + plane.w;\n    if (distance < -chunk.bounds.radius) {\n      return false;\n    }\n  }\n  return true;\n}\n\n@compute @workgroup_size(1)\nfn main() {\n  if (isInFrustum()) {\n    faces.vertexCount = 6;\n  } else {\n    faces.vertexCount = 0;\n  }\n  if (chunk.remesh == 0) {\n    workgroups[0] = 0;\n    return;\n  }\n  chunk.remesh = 0;\n  faces.instanceCount = 0;\n  workgroups[0] = u32(ceil(f32(chunkSize.x) / 4));\n  workgroups[1] = u32(ceil(f32(chunkSize.y) / 4));\n  workgroups[2] = u32(ceil(f32(chunkSize.z) / 4));\n}\n`;class I{constructor({chunkSize:e,device:n,frustum:t,workgroups:i}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:A({chunkSize:e})})}}),this.bindings=n.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.buffer}},{binding:1,resource:{buffer:i}}]})}compute(e,n){const{bindings:t,device:i,pipeline:o}=this;n.bindings.mesherSetup||(n.bindings.mesherSetup=i.createBindGroup({layout:o.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.faces}}]})),e.setPipeline(o),e.setBindGroup(0,t),e.setBindGroup(1,n.bindings.mesherSetup),e.dispatchWorkgroups(1)}}class U{constructor({chunkSize:e,device:n,frustum:t}){const i=n.createBuffer({size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.STORAGE});this.mesh=new G({chunkSize:e,device:n,workgroups:i}),this.setup=new I({chunkSize:e,device:n,frustum:t,workgroups:i})}compute(e,n){const{mesh:t,setup:i}=this;i.compute(e,n),t.compute(e,n)}}const R=({chunkSize:e})=>`\n${E.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(1)\nfn main() {\n  var bmin : vec3<f32> = vec3<f32>(f32(chunk.bounds.min[0]), f32(chunk.bounds.min[1]), f32(chunk.bounds.min[2]));\n  var bmax : vec3<f32> = vec3<f32>(f32(chunk.bounds.max[0]), f32(chunk.bounds.max[1]), f32(chunk.bounds.max[2]));\n  chunk.bounds.center = vec3<f32>(position) + (bmin + bmax) * 0.5; \n  chunk.bounds.radius = length((bmax - bmin) * 0.5);\n}\n`;class q{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:R({chunkSize:e})}),entryPoint:"main"}})}compute(e,n){const{device:t,pipeline:i}=this;n.bindings.bounds||(n.bindings.bounds=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.offset}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.bounds),e.dispatchWorkgroups(1)}}const N=({chunkSize:e})=>`\n${E.compute({chunkSize:e})}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n  var voxel = getVoxel(pos);\n  if (chunk.voxels[voxel] == 1 && chunk.voxels[getVoxel(pos + vec3<i32>(0, 1, 0))] == 0) {\n    chunk.voxels[voxel] = 2;\n  }\n}\n`;class V{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{entryPoint:"main",module:n.createShaderModule({code:N({chunkSize:e})})}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.grass||(n.bindings.grass=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.grass),e.dispatchWorkgroups(o.x,o.y,o.z)}}const F=({chunkSize:e})=>`\n${E.compute({atomicBounds:!0,atomicQueueCount:!0,chunkSize:e})}\n\n${y}\n\nfn FBM(p : vec3<f32>) -> f32 {\n  var value : f32;\n  var amplitude : f32 = 0.5;\n  var q : vec3<f32> = p;\n  for (var i : i32 = 0; i < 3; i++) {\n    value += simplexNoise3(q) * amplitude;\n    q *= 2;\n    amplitude *= 0.5;\n  }\n  return value;\n}\n\n@group(0) @binding(0) var<storage, read_write> chunk : Chunk;\n@group(0) @binding(1) var<uniform> position : vec3<i32>;\n\n@compute @workgroup_size(4, 4, 4)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n  var pos : vec3<i32> = vec3<i32>(GlobalInvocationID.xyz);\n  if (\n    pos.x >= chunkSize.x || pos.y >= chunkSize.y || pos.z >= chunkSize.z\n  ) {\n    return;\n  }\n\n  if (pos.y == chunkSize.y - 1) {\n    var voxel = getVoxel(pos);\n    chunk.light[voxel] = maxLight;\n    chunk.queues[chunk.queue].data[atomicAdd(&(chunk.queues[chunk.queue].count), 1)] = voxel;\n    return;\n  }\n\n  var wpos = vec3<f32>(position + pos);\n  if (wpos.y == 0 || wpos.y <= abs(FBM(wpos * 0.02) + 0.2) * f32(chunkSize.y) * 1.5) {\n    chunk.voxels[getVoxel(pos)] = 1;\n    atomicMin(&chunk.bounds.min[0], u32(pos.x)); \n    atomicMin(&chunk.bounds.min[1], u32(pos.y)); \n    atomicMin(&chunk.bounds.min[2], u32(pos.z));\n    atomicMax(&chunk.bounds.max[0], u32(pos.x) + 1); \n    atomicMax(&chunk.bounds.max[1], u32(pos.y) + 1); \n    atomicMax(&chunk.bounds.max[2], u32(pos.z) + 1);\n  }\n}\n`;class D{constructor({chunkSize:e,device:n}){this.device=n,this.pipeline=n.createComputePipeline({layout:"auto",compute:{module:n.createShaderModule({code:F({chunkSize:e})}),entryPoint:"main"}}),this.workgroups={x:Math.ceil(e.x/4),y:Math.ceil(e.y/4),z:Math.ceil(e.z/4)}}compute(e,n){const{device:t,pipeline:i,workgroups:o}=this;n.bindings.terrain||(n.bindings.terrain=t.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n.data}},{binding:1,resource:{buffer:n.offset}}]})),e.setPipeline(i),e.setBindGroup(0,n.bindings.terrain),e.dispatchWorkgroups(o.x,o.y,o.z)}}class ${constructor({chunkSize:e,device:n}){this.bounds=new q({chunkSize:e,device:n}),this.grass=new V({chunkSize:e,device:n}),this.terrain=new D({chunkSize:e,device:n})}compute(e,n){const{bounds:t,grass:i,terrain:o}=this;o.compute(e,n),i.compute(e,n),t.compute(e,n)}}const O=[l(1,0),l(-1,0),l(0,1),l(0,-1)],Y=c();class W{constructor({chunkSize:e={x:64,y:64,z:64},camera:n,device:t}){this.chunkSize=e,this.device=t,this.chunks={data:new Map,loaded:[]},this.frustum=new _({device:t,camera:n}),this.lighting=new L({chunkSize:e,device:t}),this.mesher=new U({chunkSize:e,device:t,frustum:this.frustum}),this.worldgen=new $({chunkSize:e,device:t})}compute(e){const{chunks:n,frustum:t,lighting:i,mesher:o,worldgen:r}=this,a=e.beginComputePass();t.compute(a),n.loaded.forEach((e=>{e.hasGenerated||(e.hasGenerated=!0,r.compute(a,e)),e.neighbors||(e.neighbors=O.map((n=>{const t=this.get(h(Y,e.position,n));return t.hasGenerated||r.compute(a,t),t}))),i.compute(a,e),o.compute(a,e)})),a.end()}get(e){const{chunks:n,chunkSize:t,device:i}=this,o=`${e[0]}:${e[1]}`;let r=n.data.get(o);return r||(r=new E({chunkSize:t,device:i,position:e}),n.data.set(o,r)),r}load(e,n,t){const{chunks:i}=this;for(let n=0,u=i.loaded.length;n<u;n++){const c=i.loaded[n];o=e,r=c.position,a=void 0,s=void 0,a=r[0]-o[0],s=r[1]-o[1],Math.hypot(a,s)>t-.5&&(i.loaded.splice(n,1),n--,u--)}var o,r,a,s;W.getGrid(n).forEach((n=>{const t=this.get(h(Y,e,n));i.loaded.includes(t)||i.loaded.push(t)}))}static getGrid(e){let n=W.grids.get(e);if(!n){n=[];for(let i=-e;i<=e;i++)for(let o=-e;o<=e;o++){d(Y,o,i);var t=f(Y);t<=e-.5&&n.push({distance:t,position:p(Y)})}n.sort((({distance:e},{distance:n})=>e-n)),n=n.map((({position:e})=>e)),W.grids.set(e,n)}return n}}W.grids=new Map;(async()=>{if(!navigator.gpu||!navigator.gpu.getPreferredCanvasFormat)throw new Error("WebGPU");const n=await navigator.gpu.requestAdapter(),t=await n.requestDevice();await(async e=>{const n=e.createShaderModule({code:"const checkConstSupport : f32 = 1;"}),{messages:t}=await n.compilationInfo();if(t.find((({type:e})=>"error"===e)))throw new Error("ConstSupport")})(t);const i=new m({device:t}),o=new W({camera:i,device:t}),r=new S({adapter:n,camera:i,device:t});document.getElementById("renderer").appendChild(r.canvas),r.setSize(window.innerWidth,window.innerHeight),window.addEventListener("resize",(()=>r.setSize(window.innerWidth,window.innerHeight)),!1),r.setClearColor(.2,.6,.6),s(i.position,0,.5*o.chunkSize.y,0);let a=performance.now()/1e3;document.addEventListener("visibilitychange",(()=>{"visible"===document.visibilityState&&(a=performance.now()/1e3)}),!1);const u=new x({position:i.position,target:document.getElementById("renderer")}),p=c(),h=l(o.chunkSize.x,o.chunkSize.z),f=l(-1,-1),v=()=>{requestAnimationFrame(v);const n=performance.now()/1e3,s=Math.min(n-a,1);var c,l,m;a=n,u.update(s),function(e,n){e[0]=Math.floor(n[0]),e[1]=Math.floor(n[1])}(p,(c=p,l=d(p,i.position[0],i.position[2]),m=h,c[0]=l[0]/m[0],c[1]=l[1]/m[1],c)),function(n,t){var i=n[0],o=n[1],r=t[0],a=t[1];return Math.abs(i-r)<=e*Math.max(1,Math.abs(i),Math.abs(r))&&Math.abs(o-a)<=e*Math.max(1,Math.abs(o),Math.abs(a))}(f,p)||(!function(e,n){e[0]=n[0],e[1]=n[1]}(f,p),o.load(p,4,5)),function(e,n,t){e[0]=n[0]+t[0],e[1]=n[1]+t[1],e[2]=n[2]+t[2]}(i.target,i.position,u.vectors.forward),i.updateView();const g=t.createCommandEncoder();o.compute(g),r.render(g,o.chunks.loaded),t.queue.submit([g.finish()])};r.voxels.atlas.compute(),requestAnimationFrame(v)})().catch((e=>{console.error(e),document.getElementById("canary").classList.add("enabled")})).finally((()=>document.getElementById("loading").classList.remove("enabled")))}();
